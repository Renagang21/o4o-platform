# E-commerce ÏãúÏä§ÌÖú API Íµ¨ÌòÑ ÏûëÏóÖ ÏßÄÏãúÏÑú

## üìã ÏûëÏóÖ Í∞úÏöî
O4O PlatformÏùò E-commerce ÏãúÏä§ÌÖú Î∞±ÏóîÎìú APIÎ•º ÏôÑÏÑ±ÌïòÎäî ÏûëÏóÖÏûÖÎãàÎã§.
ÌòÑÏû¨ ÌîÑÎ°†Ìä∏ÏóîÎìú UI(85%)ÏôÄ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏÑ§Í≥Ñ(90%)Îäî ÏôÑÏÑ±ÎêòÏóàÏúºÎÇò, API Ïó∞Îèô Î∞è Í≥†Í∏â Í∏∞Îä• Íµ¨ÌòÑÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.

## üéØ ÏûëÏóÖ Î™©Ìëú
1. Ïû¨Í≥† Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Í≥†ÎèÑÌôî (ÏûêÎèô Ïû¨Ï£ºÎ¨∏, ÏïåÎ¶º)
2. Î∂ÑÏÑù Î∞è Î≥¥Í≥†ÏÑú API Íµ¨ÌòÑ
3. Toss Payments Í≥†Í∏â Í∏∞Îä• Íµ¨ÌòÑ (Ï†ïÍ∏∞Í≤∞Ï†ú, Î∂ÄÎ∂ÑÏ∑®ÏÜå)
4. Ï£ºÎ¨∏ ÏûêÎèôÌôî ÏõåÌÅ¨ÌîåÎ°úÏö∞ Íµ¨ÌòÑ

## üìÅ ÌòÑÏû¨ ÌååÏùº Íµ¨Ï°∞
```
apps/api-server/src/
‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îú‚îÄ‚îÄ Product.ts (‚úÖ ÏôÑÏÑ±)
‚îÇ   ‚îú‚îÄ‚îÄ Order.ts (‚úÖ ÏôÑÏÑ±)
‚îÇ   ‚îú‚îÄ‚îÄ Payment.ts (‚úÖ ÏôÑÏÑ±)
‚îÇ   ‚îî‚îÄ‚îÄ Inventory.ts (‚ùå ÏÉùÏÑ± ÌïÑÏöî)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ TossPaymentsService.ts (üî∂ ÌôïÏû• ÌïÑÏöî)
‚îÇ   ‚îú‚îÄ‚îÄ InventoryService.ts (‚ùå ÏÉùÏÑ± ÌïÑÏöî)
‚îÇ   ‚îú‚îÄ‚îÄ AnalyticsService.ts (‚ùå ÏÉùÏÑ± ÌïÑÏöî)
‚îÇ   ‚îî‚îÄ‚îÄ OrderAutomationService.ts (üî∂ ÌôïÏû• ÌïÑÏöî)
‚îî‚îÄ‚îÄ controllers/
    ‚îú‚îÄ‚îÄ inventoryController.ts (‚ùå ÏÉùÏÑ± ÌïÑÏöî)
    ‚îî‚îÄ‚îÄ analyticsController.ts (‚ùå ÏÉùÏÑ± ÌïÑÏöî)
```

## üîß Phase 1: Ïû¨Í≥† Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú Íµ¨ÌòÑ

### 1.1 Inventory ÏóîÌã∞Ìã∞ ÏÉùÏÑ±
**ÌååÏùº ÏúÑÏπò**: `apps/api-server/src/entities/Inventory.ts`

```typescript
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, OneToMany, CreateDateColumn, UpdateDateColumn, Index } from 'typeorm';
import { Product } from './Product';
import { ProductVariation } from './ProductVariation';

@Entity('inventory')
@Index(['product', 'variation'])
@Index(['lastUpdated'])
export class Inventory {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => Product, product => product.inventory)
  product: Product;

  @ManyToOne(() => ProductVariation, { nullable: true })
  variation?: ProductVariation;

  @Column('int')
  currentStock: number;

  @Column('int', { default: 0 })
  reservedStock: number; // Ï£ºÎ¨∏ ÏßÑÌñâ Ï§ëÏù∏ Ïû¨Í≥†

  @Column('int', { default: 0 })
  incomingStock: number; // ÏûÖÍ≥† ÏòàÏ†ï Ïû¨Í≥†

  @Column('int')
  reorderPoint: number; // Ïû¨Ï£ºÎ¨∏Ï†ê

  @Column('int')
  reorderQuantity: number; // Ïû¨Ï£ºÎ¨∏ ÏàòÎüâ

  @Column('int', { nullable: true })
  maxStock?: number; // ÏµúÎåÄ Ïû¨Í≥†

  @Column('int', { nullable: true })
  minStock?: number; // ÏµúÏÜå Ïû¨Í≥†

  @Column('decimal', { precision: 10, scale: 2 })
  unitCost: number; // Îã®ÏúÑ ÏõêÍ∞Ä

  @Column({ nullable: true })
  location?: string; // Ï∞ΩÍ≥† ÏúÑÏπò

  @Column({ nullable: true })
  batch?: string; // Î∞∞Ïπò Î≤àÌò∏

  @Column({ type: 'date', nullable: true })
  expiryDate?: Date; // Ïú†Ìö®Í∏∞Ìïú

  @Column({
    type: 'enum',
    enum: ['in_stock', 'low_stock', 'out_of_stock', 'discontinued'],
    default: 'in_stock'
  })
  status: 'in_stock' | 'low_stock' | 'out_of_stock' | 'discontinued';

  @Column({ type: 'timestamp' })
  lastRestocked: Date;

  @Column({ type: 'timestamp' })
  lastSold: Date;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  lastUpdated: Date;

  @OneToMany(() => StockMovement, movement => movement.inventory)
  movements: StockMovement[];

  @OneToMany(() => ReorderRule, rule => rule.inventory)
  reorderRules: ReorderRule[];

  // Í∞ÄÏö© Ïû¨Í≥† Í≥ÑÏÇ∞
  get availableStock(): number {
    return this.currentStock - this.reservedStock;
  }

  // Ïû¨Ï£ºÎ¨∏ ÌïÑÏöî Ïó¨Î∂Ä
  get needsReorder(): boolean {
    return this.availableStock <= this.reorderPoint;
  }
}

@Entity('stock_movements')
@Index(['inventory', 'createdAt'])
export class StockMovement {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => Inventory, inventory => inventory.movements)
  inventory: Inventory;

  @Column({
    type: 'enum',
    enum: ['in', 'out', 'adjustment', 'reserved', 'unreserved', 'expired', 'damaged'],
  })
  type: string;

  @Column('int')
  quantity: number;

  @Column('int')
  previousStock: number;

  @Column('int')
  newStock: number;

  @Column()
  reason: string;

  @Column({ nullable: true })
  reference?: string; // Order ID, PO ID Îì±

  @Column({ type: 'text', nullable: true })
  notes?: string;

  @Column()
  performedBy: string; // User ID

  @CreateDateColumn()
  createdAt: Date;
}

@Entity('reorder_rules')
export class ReorderRule {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => Inventory, inventory => inventory.reorderRules)
  inventory: Inventory;

  @Column({ default: true })
  enabled: boolean;

  @Column('int')
  reorderPoint: number;

  @Column('int')
  reorderQuantity: number;

  @Column('int')
  leadTime: number; // Î¶¨ÎìúÌÉÄÏûÑ (Ïùº)

  @Column({ nullable: true })
  supplierId?: string;

  @Column({ nullable: true })
  supplierName?: string;

  @Column({ default: false })
  autoApprove: boolean;

  @Column({
    type: 'enum',
    enum: ['fixed', 'dynamic', 'seasonal'],
    default: 'fixed'
  })
  calculationMethod: 'fixed' | 'dynamic' | 'seasonal';

  @Column('decimal', { precision: 5, scale: 2, default: 1.5 })
  safetyStockMultiplier: number;

  @Column({ type: 'timestamp', nullable: true })
  lastTriggered?: Date;

  @Column({ type: 'timestamp', nullable: true })
  nextReviewDate?: Date;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}

@Entity('inventory_alerts')
export class InventoryAlert {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @ManyToOne(() => Inventory)
  inventory: Inventory;

  @Column({
    type: 'enum',
    enum: ['low_stock', 'out_of_stock', 'expiring', 'overstock', 'slow_moving'],
  })
  type: string;

  @Column({
    type: 'enum',
    enum: ['critical', 'warning', 'info'],
  })
  severity: 'critical' | 'warning' | 'info';

  @Column()
  message: string;

  @Column('text')
  recommendation: string;

  @Column({ default: false })
  acknowledged: boolean;

  @Column({ nullable: true })
  acknowledgedBy?: string;

  @Column({ type: 'timestamp', nullable: true })
  acknowledgedAt?: Date;

  @Column({ default: false })
  resolved: boolean;

  @Column({ type: 'timestamp', nullable: true })
  resolvedAt?: Date;

  @CreateDateColumn()
  createdAt: Date;
}
```

### 1.2 InventoryService Íµ¨ÌòÑ
**ÌååÏùº ÏúÑÏπò**: `apps/api-server/src/services/InventoryService.ts`

```typescript
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, LessThanOrEqual, MoreThan, Between } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';
import { Inventory, StockMovement, ReorderRule, InventoryAlert } from '../entities/Inventory';
import { Product } from '../entities/Product';
import { Order } from '../entities/Order';
import { EventEmitter2 } from '@nestjs/event-emitter';
import logger from '../utils/simpleLogger';

interface StockAdjustmentDto {
  inventoryId: string;
  type: 'increase' | 'decrease' | 'set';
  quantity: number;
  reason: string;
  notes?: string;
  performedBy: string;
}

interface ReorderRuleDto {
  productId: string;
  reorderPoint: number;
  reorderQuantity: number;
  leadTime: number;
  supplierId?: string;
  autoApprove?: boolean;
  calculationMethod?: 'fixed' | 'dynamic' | 'seasonal';
}

@Injectable()
export class InventoryService {
  constructor(
    @InjectRepository(Inventory)
    private inventoryRepository: Repository<Inventory>,
    @InjectRepository(StockMovement)
    private movementRepository: Repository<StockMovement>,
    @InjectRepository(ReorderRule)
    private reorderRuleRepository: Repository<ReorderRule>,
    @InjectRepository(InventoryAlert)
    private alertRepository: Repository<InventoryAlert>,
    @InjectRepository(Product)
    private productRepository: Repository<Product>,
    private eventEmitter: EventEmitter2,
  ) {}

  // Ïû¨Í≥† Ï°∞Ìöå
  async getInventory(filters?: any) {
    const query = this.inventoryRepository.createQueryBuilder('inventory')
      .leftJoinAndSelect('inventory.product', 'product')
      .leftJoinAndSelect('inventory.variation', 'variation');

    if (filters?.status) {
      query.andWhere('inventory.status = :status', { status: filters.status });
    }

    if (filters?.search) {
      query.andWhere('(product.name LIKE :search OR product.sku LIKE :search)', 
        { search: `%${filters.search}%` });
    }

    if (filters?.lowStock) {
      query.andWhere('inventory.currentStock <= inventory.reorderPoint');
    }

    return query.getMany();
  }

  // Ïû¨Í≥† Ï°∞Ï†ï
  async adjustStock(adjustment: StockAdjustmentDto) {
    const inventory = await this.inventoryRepository.findOne({
      where: { id: adjustment.inventoryId },
      relations: ['product']
    });

    if (!inventory) {
      throw new NotFoundException('Ïû¨Í≥†Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
    }

    const previousStock = inventory.currentStock;
    let newStock: number;
    let movementType: string;

    switch (adjustment.type) {
      case 'increase':
        newStock = previousStock + adjustment.quantity;
        movementType = 'in';
        break;
      case 'decrease':
        newStock = previousStock - adjustment.quantity;
        movementType = 'out';
        if (newStock < 0) {
          throw new BadRequestException('Ïû¨Í≥†Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§');
        }
        break;
      case 'set':
        newStock = adjustment.quantity;
        movementType = 'adjustment';
        break;
    }

    // Ïû¨Í≥† ÏóÖÎç∞Ïù¥Ìä∏
    inventory.currentStock = newStock;
    inventory.status = this.calculateStockStatus(inventory);
    await this.inventoryRepository.save(inventory);

    // Ïû¨Í≥† Ïù¥Îèô Í∏∞Î°ù
    const movement = this.movementRepository.create({
      inventory,
      type: movementType,
      quantity: Math.abs(newStock - previousStock),
      previousStock,
      newStock,
      reason: adjustment.reason,
      notes: adjustment.notes,
      performedBy: adjustment.performedBy
    });
    await this.movementRepository.save(movement);

    // Ïù¥Î≤§Ìä∏ Î∞úÏÉù
    this.eventEmitter.emit('inventory.adjusted', {
      inventoryId: inventory.id,
      productId: inventory.product.id,
      previousStock,
      newStock,
      adjustment
    });

    // ÏïåÎ¶º ÌôïÏù∏
    await this.checkAndCreateAlerts(inventory);

    return inventory;
  }

  // Ï£ºÎ¨∏ Ïãú Ïû¨Í≥† ÏòàÏïΩ
  async reserveStock(productId: string, quantity: number, orderId: string) {
    const inventory = await this.inventoryRepository.findOne({
      where: { product: { id: productId } }
    });

    if (!inventory) {
      throw new NotFoundException('Ïû¨Í≥†Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
    }

    if (inventory.availableStock < quantity) {
      throw new BadRequestException('Ïû¨Í≥†Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§');
    }

    inventory.reservedStock += quantity;
    await this.inventoryRepository.save(inventory);

    // ÏòàÏïΩ Í∏∞Î°ù
    const movement = this.movementRepository.create({
      inventory,
      type: 'reserved',
      quantity,
      previousStock: inventory.currentStock,
      newStock: inventory.currentStock,
      reason: 'Ï£ºÎ¨∏ ÏòàÏïΩ',
      reference: orderId,
      performedBy: 'system'
    });
    await this.movementRepository.save(movement);

    return inventory;
  }

  // Ï£ºÎ¨∏ ÏôÑÎ£å Ïãú Ïû¨Í≥† Ï∞®Í∞ê
  async deductStock(productId: string, quantity: number, orderId: string) {
    const inventory = await this.inventoryRepository.findOne({
      where: { product: { id: productId } }
    });

    if (!inventory) {
      throw new NotFoundException('Ïû¨Í≥†Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
    }

    inventory.currentStock -= quantity;
    inventory.reservedStock = Math.max(0, inventory.reservedStock - quantity);
    inventory.lastSold = new Date();
    inventory.status = this.calculateStockStatus(inventory);
    
    await this.inventoryRepository.save(inventory);

    // Ï∞®Í∞ê Í∏∞Î°ù
    const movement = this.movementRepository.create({
      inventory,
      type: 'out',
      quantity,
      previousStock: inventory.currentStock + quantity,
      newStock: inventory.currentStock,
      reason: 'Ï£ºÎ¨∏ ÏôÑÎ£å',
      reference: orderId,
      performedBy: 'system'
    });
    await this.movementRepository.save(movement);

    // Ïû¨Ï£ºÎ¨∏ ÌôïÏù∏
    if (inventory.needsReorder) {
      await this.triggerReorder(inventory);
    }

    return inventory;
  }

  // Ïû¨Ï£ºÎ¨∏ Í∑úÏπô ÏÉùÏÑ±/ÏóÖÎç∞Ïù¥Ìä∏
  async upsertReorderRule(ruleDto: ReorderRuleDto) {
    const inventory = await this.inventoryRepository.findOne({
      where: { product: { id: ruleDto.productId } }
    });

    if (!inventory) {
      throw new NotFoundException('Ïû¨Í≥†Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
    }

    let rule = await this.reorderRuleRepository.findOne({
      where: { inventory: { id: inventory.id } }
    });

    if (!rule) {
      rule = this.reorderRuleRepository.create({
        inventory,
        ...ruleDto
      });
    } else {
      Object.assign(rule, ruleDto);
    }

    // ÎèôÏ†Å Í≥ÑÏÇ∞ Î∞©ÏãùÏùº Í≤ΩÏö∞ Ïû¨Ï£ºÎ¨∏Ï†ê Ïû¨Í≥ÑÏÇ∞
    if (rule.calculationMethod === 'dynamic') {
      rule.reorderPoint = await this.calculateDynamicReorderPoint(inventory);
    }

    return this.reorderRuleRepository.save(rule);
  }

  // ÏûêÎèô Ïû¨Ï£ºÎ¨∏ Ìä∏Î¶¨Í±∞
  private async triggerReorder(inventory: Inventory) {
    const rule = await this.reorderRuleRepository.findOne({
      where: { inventory: { id: inventory.id }, enabled: true }
    });

    if (!rule) return;

    // Ïù¥ÎØ∏ ÏµúÍ∑ºÏóê Ìä∏Î¶¨Í±∞Îêú Í≤ΩÏö∞ Ïä§ÌÇµ
    if (rule.lastTriggered) {
      const hoursSinceLastTrigger = (Date.now() - rule.lastTriggered.getTime()) / (1000 * 60 * 60);
      if (hoursSinceLastTrigger < 24) return;
    }

    // Íµ¨Îß§ Ï£ºÎ¨∏ ÏÉùÏÑ±
    const purchaseOrder = {
      supplierId: rule.supplierId,
      productId: inventory.product.id,
      quantity: rule.reorderQuantity,
      expectedDelivery: new Date(Date.now() + rule.leadTime * 24 * 60 * 60 * 1000),
      autoGenerated: true,
      status: rule.autoApprove ? 'approved' : 'pending'
    };

    // Ïù¥Î≤§Ìä∏ Î∞úÏÉù
    this.eventEmitter.emit('reorder.triggered', {
      inventory,
      rule,
      purchaseOrder
    });

    // Í∑úÏπô ÏóÖÎç∞Ïù¥Ìä∏
    rule.lastTriggered = new Date();
    await this.reorderRuleRepository.save(rule);

    // ÏïåÎ¶º ÏÉùÏÑ±
    await this.createAlert(inventory, 'low_stock', 'warning', 
      `${inventory.product.name}Ïùò Ïû¨Í≥†Í∞Ä Ïû¨Ï£ºÎ¨∏Ï†êÏóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§. ÏûêÎèô Ïû¨Ï£ºÎ¨∏Ïù¥ ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§.`);

    logger.info(`Auto reorder triggered for product ${inventory.product.id}`);
  }

  // Ïû¨Í≥† ÏÉÅÌÉú Í≥ÑÏÇ∞
  private calculateStockStatus(inventory: Inventory): 'in_stock' | 'low_stock' | 'out_of_stock' | 'discontinued' {
    if (inventory.currentStock === 0) return 'out_of_stock';
    if (inventory.currentStock <= inventory.reorderPoint) return 'low_stock';
    return 'in_stock';
  }

  // ÎèôÏ†Å Ïû¨Ï£ºÎ¨∏Ï†ê Í≥ÑÏÇ∞
  private async calculateDynamicReorderPoint(inventory: Inventory): Promise<number> {
    // ÏµúÍ∑º 30Ïùº ÌåêÎß§ Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Í≥ÑÏÇ∞
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    
    const movements = await this.movementRepository.find({
      where: {
        inventory: { id: inventory.id },
        type: 'out',
        createdAt: MoreThan(thirtyDaysAgo)
      }
    });

    const totalSold = movements.reduce((sum, m) => sum + m.quantity, 0);
    const avgDailyUsage = totalSold / 30;
    
    const rule = await this.reorderRuleRepository.findOne({
      where: { inventory: { id: inventory.id } }
    });

    const leadTime = rule?.leadTime || 7;
    const safetyStock = avgDailyUsage * (rule?.safetyStockMultiplier || 1.5);

    return Math.ceil((avgDailyUsage * leadTime) + safetyStock);
  }

  // ÏïåÎ¶º ÏÉùÏÑ± Î∞è ÌôïÏù∏
  private async checkAndCreateAlerts(inventory: Inventory) {
    // Ïû¨Í≥† Î∂ÄÏ°± ÏïåÎ¶º
    if (inventory.status === 'out_of_stock') {
      await this.createAlert(inventory, 'out_of_stock', 'critical', 
        `${inventory.product.name}Ïùò Ïû¨Í≥†Í∞Ä ÏÜåÏßÑÎêòÏóàÏäµÎãàÎã§.`);
    } else if (inventory.status === 'low_stock') {
      await this.createAlert(inventory, 'low_stock', 'warning',
        `${inventory.product.name}Ïùò Ïû¨Í≥†Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§. (ÌòÑÏû¨: ${inventory.currentStock}Í∞ú)`);
    }

    // Ïú†Ìö®Í∏∞Ìïú ÏïåÎ¶º
    if (inventory.expiryDate) {
      const daysUntilExpiry = (inventory.expiryDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24);
      if (daysUntilExpiry <= 30) {
        await this.createAlert(inventory, 'expiring', 'warning',
          `${inventory.product.name}Ïùò Ïú†Ìö®Í∏∞ÌïúÏù¥ ${Math.floor(daysUntilExpiry)}Ïùº ÎÇ®ÏïòÏäµÎãàÎã§.`);
      }
    }

    // Í≥ºÏû¨Í≥† ÏïåÎ¶º
    if (inventory.maxStock && inventory.currentStock > inventory.maxStock) {
      await this.createAlert(inventory, 'overstock', 'info',
        `${inventory.product.name}Ïùò Ïû¨Í≥†Í∞Ä ÏµúÎåÄ ÏàòÏ§ÄÏùÑ Ï¥àÍ≥ºÌñàÏäµÎãàÎã§.`);
    }
  }

  private async createAlert(inventory: Inventory, type: string, severity: 'critical' | 'warning' | 'info', message: string) {
    // ÎèôÏùºÌïú ÎØ∏Ìï¥Í≤∞ ÏïåÎ¶ºÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    const existingAlert = await this.alertRepository.findOne({
      where: {
        inventory: { id: inventory.id },
        type,
        resolved: false
      }
    });

    if (existingAlert) return;

    const alert = this.alertRepository.create({
      inventory,
      type,
      severity,
      message,
      recommendation: this.getRecommendation(type, inventory)
    });

    await this.alertRepository.save(alert);

    // Ï§ëÏöî ÏïåÎ¶ºÏùÄ Ïù¥Î©îÏùº Ï†ÑÏÜ°
    if (severity === 'critical') {
      this.eventEmitter.emit('alert.critical', alert);
    }
  }

  private getRecommendation(type: string, inventory: Inventory): string {
    switch (type) {
      case 'out_of_stock':
        return 'Ï¶âÏãú Ïû¨Ï£ºÎ¨∏ÏùÑ ÏßÑÌñâÌïòÍ±∞ÎÇò ÎåÄÏ≤¥ ÏÉÅÌíàÏùÑ Ï§ÄÎπÑÌïòÏÑ∏Ïöî.';
      case 'low_stock':
        return `Ïû¨Ï£ºÎ¨∏ÏùÑ Ï§ÄÎπÑÌïòÏÑ∏Ïöî. Í∂åÏû• Ïû¨Ï£ºÎ¨∏Îüâ: ${inventory.reorderQuantity}Í∞ú`;
      case 'expiring':
        return 'Ìï†Ïù∏ ÌîÑÎ°úÎ™®ÏÖòÏùÑ ÏßÑÌñâÌïòÍ±∞ÎÇò Î∞òÌíà Ï≤òÎ¶¨Î•º Í≥†Î†§ÌïòÏÑ∏Ïöî.';
      case 'overstock':
        return 'ÌîÑÎ°úÎ™®ÏÖòÏùÑ ÌÜµÌï¥ Ïû¨Í≥†Î•º Ï§ÑÏù¥Í±∞ÎÇò Ïû¨Ï£ºÎ¨∏ Í∑úÏπôÏùÑ Ï°∞Ï†ïÌïòÏÑ∏Ïöî.';
      default:
        return 'Ïû¨Í≥† ÏÉÅÌÉúÎ•º ÌôïÏù∏ÌïòÍ≥† Ï†ÅÏ†àÌïú Ï°∞ÏπòÎ•º Ï∑®ÌïòÏÑ∏Ïöî.';
    }
  }

  // Ï†ïÍ∏∞ ÏûëÏóÖ: Ïû¨Í≥† ÏÉÅÌÉú ÌôïÏù∏ (Îß§ÏãúÍ∞Ñ)
  @Cron(CronExpression.EVERY_HOUR)
  async checkInventoryStatus() {
    const inventories = await this.inventoryRepository.find({
      relations: ['product']
    });

    for (const inventory of inventories) {
      // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      const oldStatus = inventory.status;
      inventory.status = this.calculateStockStatus(inventory);
      
      if (oldStatus !== inventory.status) {
        await this.inventoryRepository.save(inventory);
        await this.checkAndCreateAlerts(inventory);
      }

      // Ïû¨Ï£ºÎ¨∏ ÌôïÏù∏
      if (inventory.needsReorder) {
        await this.triggerReorder(inventory);
      }
    }

    logger.info('Inventory status check completed');
  }

  // Ïû¨Í≥† ÌöåÏ†ÑÏú® Í≥ÑÏÇ∞
  async calculateTurnoverRate(productId: string, period: number = 365): Promise<number> {
    const inventory = await this.inventoryRepository.findOne({
      where: { product: { id: productId } }
    });

    if (!inventory) return 0;

    const startDate = new Date(Date.now() - period * 24 * 60 * 60 * 1000);
    
    const movements = await this.movementRepository.find({
      where: {
        inventory: { id: inventory.id },
        type: 'out',
        createdAt: MoreThan(startDate)
      }
    });

    const totalSold = movements.reduce((sum, m) => sum + m.quantity, 0);
    const avgInventory = (inventory.currentStock + inventory.maxStock) / 2;

    return avgInventory > 0 ? totalSold / avgInventory : 0;
  }

  // Ïû¨Í≥† Í∞ÄÏπò Í≥ÑÏÇ∞
  async calculateInventoryValue(): Promise<number> {
    const inventories = await this.inventoryRepository.find();
    return inventories.reduce((total, inv) => total + (inv.currentStock * inv.unitCost), 0);
  }

  // Îç∞ÎìúÏä§ÌÜ° ÏãùÎ≥Ñ
  async identifyDeadStock(days: number = 90): Promise<Inventory[]> {
    const cutoffDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
    
    return this.inventoryRepository.find({
      where: {
        lastSold: LessThanOrEqual(cutoffDate),
        currentStock: MoreThan(0)
      },
      relations: ['product']
    });
  }

  // Ïû¨Í≥† ÏòàÏ∏°
  async forecastInventory(productId: string, days: number = 30): Promise<any> {
    const inventory = await this.inventoryRepository.findOne({
      where: { product: { id: productId } },
      relations: ['product']
    });

    if (!inventory) {
      throw new NotFoundException('Ïû¨Í≥†Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§');
    }

    // Í≥ºÍ±∞ ÌåêÎß§ Îç∞Ïù¥ÌÑ∞ Î∂ÑÏÑù
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    const movements = await this.movementRepository.find({
      where: {
        inventory: { id: inventory.id },
        type: 'out',
        createdAt: MoreThan(thirtyDaysAgo)
      }
    });

    const totalSold = movements.reduce((sum, m) => sum + m.quantity, 0);
    const avgDailyUsage = totalSold / 30;
    
    // ÏòàÏ∏° Í≥ÑÏÇ∞
    const forecast = [];
    let projectedStock = inventory.currentStock;
    
    for (let i = 1; i <= days; i++) {
      projectedStock -= avgDailyUsage;
      
      // Ïû¨Ï£ºÎ¨∏ ÏòàÏ†ïÏù¥ ÏûàÎäî Í≤ΩÏö∞
      if (projectedStock <= inventory.reorderPoint && i % 7 === 0) {
        projectedStock += inventory.reorderQuantity;
      }
      
      forecast.push({
        day: i,
        date: new Date(Date.now() + i * 24 * 60 * 60 * 1000),
        projectedStock: Math.max(0, projectedStock),
        willReorder: projectedStock <= inventory.reorderPoint
      });
    }

    return {
      product: inventory.product,
      currentStock: inventory.currentStock,
      avgDailyUsage,
      daysUntilOutOfStock: Math.floor(inventory.currentStock / avgDailyUsage),
      forecast
    };
  }
}
```

## üîß Phase 2: Î∂ÑÏÑù ÏÑúÎπÑÏä§ Íµ¨ÌòÑ

### 2.1 AnalyticsService Íµ¨ÌòÑ
**ÌååÏùº ÏúÑÏπò**: `apps/api-server/src/services/AnalyticsService.ts`

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between, MoreThan } from 'typeorm';
import { Order } from '../entities/Order';
import { Product } from '../entities/Product';
import { User } from '../entities/User';
import { Payment } from '../entities/Payment';
import { Inventory } from '../entities/Inventory';
import { Cache } from 'cache-manager';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject } from '@nestjs/common';

interface DateRange {
  start: Date;
  end: Date;
}

interface RevenueAnalytics {
  current: number;
  previous: number;
  growth: number;
  chart: Array<{ date: string; value: number }>;
}

interface ProductAnalytics {
  topSelling: Array<any>;
  lowStock: Array<any>;
  categories: Array<any>;
}

@Injectable()
export class AnalyticsService {
  constructor(
    @InjectRepository(Order)
    private orderRepository: Repository<Order>,
    @InjectRepository(Product)
    private productRepository: Repository<Product>,
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(Payment)
    private paymentRepository: Repository<Payment>,
    @InjectRepository(Inventory)
    private inventoryRepository: Repository<Inventory>,
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
  ) {}

  // ÎåÄÏãúÎ≥¥Îìú ÌÜµÍ≥Ñ
  async getDashboardStats(period: string = 'month') {
    const cacheKey = `dashboard-stats-${period}`;
    const cached = await this.cacheManager.get(cacheKey);
    if (cached) return cached;

    const { start, end } = this.getDateRange(period);
    const { previousStart, previousEnd } = this.getPreviousDateRange(period);

    // ÌòÑÏû¨ Í∏∞Í∞Ñ Îß§Ï∂ú
    const currentRevenue = await this.calculateRevenue(start, end);
    const previousRevenue = await this.calculateRevenue(previousStart, previousEnd);
    const revenueGrowth = this.calculateGrowthRate(currentRevenue, previousRevenue);

    // Ï£ºÎ¨∏ ÌÜµÍ≥Ñ
    const orderStats = await this.getOrderStats(start, end);
    
    // Í≥†Í∞ù ÌÜµÍ≥Ñ
    const customerStats = await this.getCustomerStats(start, end);

    // ÏÉÅÌíà ÌÜµÍ≥Ñ
    const productStats = await this.getProductStats(start, end);

    const stats = {
      revenue: {
        current: currentRevenue,
        previous: previousRevenue,
        growth: revenueGrowth,
        chart: await this.getRevenueChart(start, end)
      },
      orders: orderStats,
      customers: customerStats,
      products: productStats,
      inventory: await this.getInventoryStats()
    };

    // Ï∫êÏãú Ï†ÄÏû• (5Î∂Ñ)
    await this.cacheManager.set(cacheKey, stats, 300000);
    
    return stats;
  }

  // Îß§Ï∂ú Í≥ÑÏÇ∞
  private async calculateRevenue(start: Date, end: Date): Promise<number> {
    const result = await this.orderRepository
      .createQueryBuilder('order')
      .select('SUM(order.totalAmount)', 'total')
      .where('order.status = :status', { status: 'completed' })
      .andWhere('order.createdAt BETWEEN :start AND :end', { start, end })
      .getRawOne();
    
    return result?.total || 0;
  }

  // Îß§Ï∂ú Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞
  private async getRevenueChart(start: Date, end: Date) {
    const days = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
    const chart = [];

    for (let i = 0; i < days; i++) {
      const dayStart = new Date(start.getTime() + i * 24 * 60 * 60 * 1000);
      const dayEnd = new Date(dayStart.getTime() + 24 * 60 * 60 * 1000);
      
      const revenue = await this.calculateRevenue(dayStart, dayEnd);
      
      chart.push({
        date: dayStart.toLocaleDateString(),
        value: revenue
      });
    }

    return chart;
  }

  // Ï£ºÎ¨∏ ÌÜµÍ≥Ñ
  private async getOrderStats(start: Date, end: Date) {
    const orders = await this.orderRepository.find({
      where: {
        createdAt: Between(start, end)
      }
    });

    const completed = orders.filter(o => o.status === 'completed').length;
    const pending = orders.filter(o => ['pending', 'processing'].includes(o.status)).length;
    const cancelled = orders.filter(o => o.status === 'cancelled').length;
    
    const totalRevenue = orders
      .filter(o => o.status === 'completed')
      .reduce((sum, o) => sum + o.totalAmount, 0);

    return {
      total: orders.length,
      completed,
      pending,
      cancelled,
      averageValue: orders.length > 0 ? totalRevenue / completed : 0,
      chart: await this.getOrderChart(start, end)
    };
  }

  // Í≥†Í∞ù ÌÜµÍ≥Ñ
  private async getCustomerStats(start: Date, end: Date) {
    const totalCustomers = await this.userRepository.count({
      where: { role: 'customer' }
    });

    const newCustomers = await this.userRepository.count({
      where: {
        role: 'customer',
        createdAt: Between(start, end)
      }
    });

    // Ïû¨Íµ¨Îß§ Í≥†Í∞ù Í≥ÑÏÇ∞
    const returningCustomers = await this.orderRepository
      .createQueryBuilder('order')
      .select('COUNT(DISTINCT order.userId)', 'count')
      .where('order.createdAt BETWEEN :start AND :end', { start, end })
      .groupBy('order.userId')
      .having('COUNT(order.id) > 1')
      .getRawOne();

    // Í≥†Í∞ù ÏÑ∏Í∑∏Î®ºÌä∏
    const segments = await this.getCustomerSegments();

    return {
      total: totalCustomers,
      new: newCustomers,
      returning: returningCustomers?.count || 0,
      churnRate: await this.calculateChurnRate(start, end),
      lifetime: await this.calculateCustomerLifetimeValue(),
      segments
    };
  }

  // ÏÉÅÌíà ÌÜµÍ≥Ñ
  private async getProductStats(start: Date, end: Date) {
    // Î≤†Ïä§Ìä∏ÏÖÄÎü¨
    const topSelling = await this.orderRepository
      .createQueryBuilder('order')
      .leftJoin('order.orderItems', 'item')
      .leftJoin('item.product', 'product')
      .select('product.id', 'id')
      .addSelect('product.name', 'name')
      .addSelect('SUM(item.quantity)', 'sales')
      .addSelect('SUM(item.price * item.quantity)', 'revenue')
      .where('order.createdAt BETWEEN :start AND :end', { start, end })
      .andWhere('order.status = :status', { status: 'completed' })
      .groupBy('product.id')
      .orderBy('sales', 'DESC')
      .limit(5)
      .getRawMany();

    // Ïû¨Í≥† Î∂ÄÏ°± ÏÉÅÌíà
    const lowStock = await this.inventoryRepository
      .createQueryBuilder('inventory')
      .leftJoinAndSelect('inventory.product', 'product')
      .where('inventory.currentStock <= inventory.reorderPoint')
      .orderBy('inventory.currentStock', 'ASC')
      .limit(5)
      .getMany();

    // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÌåêÎß§
    const categories = await this.orderRepository
      .createQueryBuilder('order')
      .leftJoin('order.orderItems', 'item')
      .leftJoin('item.product', 'product')
      .leftJoin('product.category', 'category')
      .select('category.name', 'name')
      .addSelect('SUM(item.quantity)', 'sales')
      .where('order.createdAt BETWEEN :start AND :end', { start, end })
      .andWhere('order.status = :status', { status: 'completed' })
      .groupBy('category.id')
      .getRawMany();

    const totalSales = categories.reduce((sum, c) => sum + parseInt(c.sales), 0);
    const categoriesWithPercentage = categories.map(c => ({
      ...c,
      percentage: (parseInt(c.sales) / totalSales) * 100
    }));

    return {
      topSelling,
      lowStock: lowStock.map(inv => ({
        id: inv.product.id,
        name: inv.product.name,
        stock: inv.currentStock,
        reorderPoint: inv.reorderPoint
      })),
      categories: categoriesWithPercentage
    };
  }

  // Ïû¨Í≥† ÌÜµÍ≥Ñ
  private async getInventoryStats() {
    const inventories = await this.inventoryRepository.find();
    
    const totalValue = inventories.reduce((sum, inv) => 
      sum + (inv.currentStock * inv.unitCost), 0);
    
    const avgTurnoverRate = await this.calculateAverageTurnoverRate();
    
    const deadStock = await this.inventoryRepository
      .createQueryBuilder('inventory')
      .where('inventory.lastSold < :date', { 
        date: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000) 
      })
      .andWhere('inventory.currentStock > 0')
      .getMany();
    
    const deadStockValue = deadStock.reduce((sum, inv) => 
      sum + (inv.currentStock * inv.unitCost), 0);

    return {
      totalValue,
      turnoverRate: avgTurnoverRate,
      deadStock: deadStockValue,
      avgDaysToSell: await this.calculateAverageDaysToSell()
    };
  }

  // Í≥†Í∞ù ÏÑ∏Í∑∏Î®ºÌä∏ Î∂ÑÏÑù
  private async getCustomerSegments() {
    const segments = [
      { segment: 'VIP', minOrders: 10, minSpent: 1000000 },
      { segment: 'ÏùºÎ∞ò', minOrders: 3, minSpent: 100000 },
      { segment: 'Ïã†Í∑ú', minOrders: 0, minSpent: 0 }
    ];

    const result = [];
    
    for (const segment of segments) {
      const customers = await this.userRepository
        .createQueryBuilder('user')
        .leftJoin('user.orders', 'order')
        .select('COUNT(DISTINCT user.id)', 'count')
        .addSelect('SUM(order.totalAmount)', 'value')
        .where('order.status = :status', { status: 'completed' })
        .groupBy('user.id')
        .having('COUNT(order.id) >= :minOrders', { minOrders: segment.minOrders })
        .andHaving('SUM(order.totalAmount) >= :minSpent', { minSpent: segment.minSpent })
        .getRawOne();

      result.push({
        segment: segment.segment,
        count: customers?.count || 0,
        value: customers?.value || 0
      });
    }

    return result;
  }

  // Ïù¥ÌÉàÎ•† Í≥ÑÏÇ∞
  private async calculateChurnRate(start: Date, end: Date): Promise<number> {
    const activeCustomersPrevious = await this.orderRepository
      .createQueryBuilder('order')
      .select('COUNT(DISTINCT order.userId)', 'count')
      .where('order.createdAt < :start', { start })
      .getRawOne();

    const activeCustomersCurrent = await this.orderRepository
      .createQueryBuilder('order')
      .select('COUNT(DISTINCT order.userId)', 'count')
      .where('order.createdAt BETWEEN :start AND :end', { start, end })
      .getRawOne();

    if (!activeCustomersPrevious?.count) return 0;
    
    const churnedCustomers = activeCustomersPrevious.count - activeCustomersCurrent.count;
    return (churnedCustomers / activeCustomersPrevious.count) * 100;
  }

  // Í≥†Í∞ù ÏÉùÏï† Í∞ÄÏπò Í≥ÑÏÇ∞
  private async calculateCustomerLifetimeValue(): Promise<number> {
    const result = await this.orderRepository
      .createQueryBuilder('order')
      .select('AVG(subquery.total)', 'ltv')
      .from(subquery => {
        return subquery
          .select('SUM(order.totalAmount)', 'total')
          .from(Order, 'order')
          .where('order.status = :status', { status: 'completed' })
          .groupBy('order.userId');
      }, 'subquery')
      .getRawOne();

    return result?.ltv || 0;
  }

  // ÌèâÍ∑† Ïû¨Í≥† ÌöåÏ†ÑÏú®
  private async calculateAverageTurnoverRate(): Promise<number> {
    const inventories = await this.inventoryRepository.find();
    let totalRate = 0;
    let count = 0;

    for (const inventory of inventories) {
      const movements = await this.movementRepository.find({
        where: {
          inventory: { id: inventory.id },
          type: 'out',
          createdAt: MoreThan(new Date(Date.now() - 365 * 24 * 60 * 60 * 1000))
        }
      });

      const totalSold = movements.reduce((sum, m) => sum + m.quantity, 0);
      if (inventory.currentStock > 0) {
        totalRate += totalSold / inventory.currentStock;
        count++;
      }
    }

    return count > 0 ? totalRate / count : 0;
  }

  // ÌèâÍ∑† ÌåêÎß§ ÏÜåÏöîÏùº
  private async calculateAverageDaysToSell(): Promise<number> {
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    
    const orders = await this.orderRepository.find({
      where: {
        status: 'completed',
        createdAt: MoreThan(thirtyDaysAgo)
      },
      relations: ['orderItems', 'orderItems.product']
    });

    if (orders.length === 0) return 0;

    let totalDays = 0;
    let count = 0;

    for (const order of orders) {
      for (const item of order.orderItems) {
        const product = item.product;
        // Ï†úÌíà Îì±Î°ùÏùºÎ∂ÄÌÑ∞ ÌåêÎß§ÏùºÍπåÏßÄÏùò ÏùºÏàò Í≥ÑÏÇ∞
        const daysToSell = Math.ceil(
          (order.createdAt.getTime() - product.createdAt.getTime()) / (1000 * 60 * 60 * 24)
        );
        totalDays += daysToSell;
        count++;
      }
    }

    return count > 0 ? Math.round(totalDays / count) : 0;
  }

  // ÎÇ†Ïßú Î≤îÏúÑ Í≥ÑÏÇ∞
  private getDateRange(period: string): DateRange {
    const end = new Date();
    let start: Date;

    switch (period) {
      case 'today':
        start = new Date(end.getFullYear(), end.getMonth(), end.getDate());
        break;
      case 'week':
        start = new Date(end.getTime() - 7 * 24 * 60 * 60 * 1000);
        break;
      case 'month':
        start = new Date(end.getFullYear(), end.getMonth(), 1);
        break;
      case 'quarter':
        const quarterMonth = Math.floor(end.getMonth() / 3) * 3;
        start = new Date(end.getFullYear(), quarterMonth, 1);
        break;
      case 'year':
        start = new Date(end.getFullYear(), 0, 1);
        break;
      default:
        start = new Date(end.getFullYear(), end.getMonth(), 1);
    }

    return { start, end };
  }

  private getPreviousDateRange(period: string): DateRange {
    const { start, end } = this.getDateRange(period);
    const duration = end.getTime() - start.getTime();
    
    return {
      previousStart: new Date(start.getTime() - duration),
      previousEnd: new Date(start.getTime() - 1)
    };
  }

  private calculateGrowthRate(current: number, previous: number): number {
    if (previous === 0) return current > 0 ? 100 : 0;
    return ((current - previous) / previous) * 100;
  }

  // Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
  async generateReport(type: string, period: string, format: 'json' | 'csv' | 'pdf' = 'json') {
    const data = await this.getDashboardStats(period);
    
    switch (format) {
      case 'json':
        return data;
      case 'csv':
        return this.convertToCSV(data);
      case 'pdf':
        return this.generatePDFReport(data);
      default:
        return data;
    }
  }

  private convertToCSV(data: any): string {
    // CSV Î≥ÄÌôò Î°úÏßÅ
    const lines = [];
    lines.push('Metric,Value');
    lines.push(`Total Revenue,${data.revenue.current}`);
    lines.push(`Revenue Growth,${data.revenue.growth}%`);
    lines.push(`Total Orders,${data.orders.total}`);
    lines.push(`Average Order Value,${data.orders.averageValue}`);
    // ... Ï∂îÍ∞Ä Î©îÌä∏Î¶≠
    return lines.join('\n');
  }

  private async generatePDFReport(data: any): Promise<Buffer> {
    // PDF ÏÉùÏÑ± Î°úÏßÅ (puppeteer ÎòêÎäî pdfkit ÏÇ¨Ïö©)
    // Íµ¨ÌòÑ ÏòàÏ†ï
    return Buffer.from('');
  }
}

// StockMovement import Ï∂îÍ∞Ä
import { StockMovement } from '../entities/Inventory';
```

## üîß Phase 3: Controller Íµ¨ÌòÑ

### 3.1 InventoryController ÏÉùÏÑ±
**ÌååÏùº ÏúÑÏπò**: `apps/api-server/src/controllers/inventoryController.ts`

```typescript
import { Controller, Get, Post, Put, Body, Param, Query, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiResponse, ApiBearerAuth } from '@nestjs/swagger';
import { JwtAuthGuard } from '../guards/jwt-auth.guard';
import { RolesGuard } from '../guards/roles.guard';
import { Roles } from '../decorators/roles.decorator';
import { InventoryService } from '../services/InventoryService';

@ApiTags('inventory')
@Controller('inventory')
@UseGuards(JwtAuthGuard, RolesGuard)
@ApiBearerAuth()
export class InventoryController {
  constructor(private readonly inventoryService: InventoryService) {}

  @Get()
  @Roles('admin', 'manager', 'staff')
  @ApiOperation({ summary: 'Ïû¨Í≥† Î™©Î°ù Ï°∞Ìöå' })
  async getInventory(@Query() filters: any) {
    const data = await this.inventoryService.getInventory(filters);
    return { success: true, data };
  }

  @Post('adjust')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ïû¨Í≥† Ï°∞Ï†ï' })
  async adjustStock(@Body() adjustment: any) {
    const data = await this.inventoryService.adjustStock(adjustment);
    return { success: true, data };
  }

  @Get('alerts')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ïû¨Í≥† ÏïåÎ¶º Ï°∞Ìöå' })
  async getAlerts(@Query('severity') severity?: string) {
    const alerts = await this.inventoryService.getAlerts(severity);
    return { success: true, data: alerts };
  }

  @Post('alerts/:id/acknowledge')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'ÏïåÎ¶º ÌôïÏù∏ Ï≤òÎ¶¨' })
  async acknowledgeAlert(@Param('id') id: string) {
    await this.inventoryService.acknowledgeAlert(id);
    return { success: true };
  }

  @Get(':id/movements')
  @Roles('admin', 'manager', 'staff')
  @ApiOperation({ summary: 'Ïû¨Í≥† Ïù¥Îèô ÎÇ¥Ïó≠ Ï°∞Ìöå' })
  async getMovements(@Param('id') id: string) {
    const movements = await this.inventoryService.getMovements(id);
    return { success: true, data: movements };
  }

  @Get(':id/forecast')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ïû¨Í≥† ÏòàÏ∏°' })
  async getForecast(@Param('id') id: string, @Query('days') days: number = 30) {
    const forecast = await this.inventoryService.forecastInventory(id, days);
    return { success: true, data: forecast };
  }

  @Get('reorder/settings')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ïû¨Ï£ºÎ¨∏ ÏÑ§Ï†ï Ï°∞Ìöå' })
  async getReorderSettings() {
    const settings = await this.inventoryService.getReorderSettings();
    return { success: true, data: settings };
  }

  @Put('reorder/settings')
  @Roles('admin')
  @ApiOperation({ summary: 'Ïû¨Ï£ºÎ¨∏ ÏÑ§Ï†ï ÏóÖÎç∞Ïù¥Ìä∏' })
  async updateReorderSettings(@Body() settings: any) {
    const data = await this.inventoryService.updateReorderSettings(settings);
    return { success: true, data };
  }

  @Get('reorder/rules')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ïû¨Ï£ºÎ¨∏ Í∑úÏπô Î™©Î°ù' })
  async getReorderRules() {
    const rules = await this.inventoryService.getReorderRules();
    return { success: true, data: rules };
  }

  @Put('reorder/rules/:id')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ïû¨Ï£ºÎ¨∏ Í∑úÏπô ÏóÖÎç∞Ïù¥Ìä∏' })
  async updateReorderRule(@Param('id') id: string, @Body() rule: any) {
    const data = await this.inventoryService.updateReorderRule(id, rule);
    return { success: true, data };
  }

  @Get('dead-stock')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Îç∞ÎìúÏä§ÌÜ° Ï°∞Ìöå' })
  async getDeadStock(@Query('days') days: number = 90) {
    const deadStock = await this.inventoryService.identifyDeadStock(days);
    return { success: true, data: deadStock };
  }

  @Get('value')
  @Roles('admin')
  @ApiOperation({ summary: 'Ï¥ù Ïû¨Í≥† Í∞ÄÏπò Ï°∞Ìöå' })
  async getInventoryValue() {
    const value = await this.inventoryService.calculateInventoryValue();
    return { success: true, data: { totalValue: value } };
  }
}
```

### 3.2 AnalyticsController ÏÉùÏÑ±
**ÌååÏùº ÏúÑÏπò**: `apps/api-server/src/controllers/analyticsController.ts`

```typescript
import { Controller, Get, Query, UseGuards } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth } from '@nestjs/swagger';
import { JwtAuthGuard } from '../guards/jwt-auth.guard';
import { RolesGuard } from '../guards/roles.guard';
import { Roles } from '../decorators/roles.decorator';
import { AnalyticsService } from '../services/AnalyticsService';

@ApiTags('analytics')
@Controller('analytics')
@UseGuards(JwtAuthGuard, RolesGuard)
@ApiBearerAuth()
export class AnalyticsController {
  constructor(private readonly analyticsService: AnalyticsService) {}

  @Get('e-commerce')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'E-commerce ÎåÄÏãúÎ≥¥Îìú ÌÜµÍ≥Ñ' })
  async getECommerceStats(@Query('period') period: string = 'month') {
    const stats = await this.analyticsService.getDashboardStats(period);
    return { success: true, data: stats };
  }

  @Get('revenue')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Îß§Ï∂ú Î∂ÑÏÑù' })
  async getRevenueAnalytics(
    @Query('period') period: string = 'month',
    @Query('compare') compare: boolean = false
  ) {
    const revenue = await this.analyticsService.getRevenueAnalytics(period, compare);
    return { success: true, data: revenue };
  }

  @Get('products')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'ÏÉÅÌíà Î∂ÑÏÑù' })
  async getProductAnalytics(@Query('period') period: string = 'month') {
    const products = await this.analyticsService.getProductAnalytics(period);
    return { success: true, data: products };
  }

  @Get('customers')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Í≥†Í∞ù Î∂ÑÏÑù' })
  async getCustomerAnalytics(@Query('period') period: string = 'month') {
    const customers = await this.analyticsService.getCustomerAnalytics(period);
    return { success: true, data: customers };
  }

  @Get('inventory')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ïû¨Í≥† Î∂ÑÏÑù' })
  async getInventoryAnalytics() {
    const inventory = await this.analyticsService.getInventoryAnalytics();
    return { success: true, data: inventory };
  }

  @Get('report')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Î≥¥Í≥†ÏÑú ÏÉùÏÑ±' })
  async generateReport(
    @Query('type') type: string,
    @Query('period') period: string,
    @Query('format') format: 'json' | 'csv' | 'pdf' = 'json'
  ) {
    const report = await this.analyticsService.generateReport(type, period, format);
    return { success: true, data: report };
  }

  @Get('realtime')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ïã§ÏãúÍ∞Ñ ÏßÄÌëú' })
  async getRealtimeMetrics() {
    const metrics = await this.analyticsService.getRealtimeMetrics();
    return { success: true, data: metrics };
  }

  @Get('trends')
  @Roles('admin', 'manager')
  @ApiOperation({ summary: 'Ìä∏Î†åÎìú Î∂ÑÏÑù' })
  async getTrends(@Query('metric') metric: string, @Query('period') period: string = 'month') {
    const trends = await this.analyticsService.getTrends(metric, period);
    return { success: true, data: trends };
  }
}
```

## üîß Phase 4: Toss Payments Í≥†Í∏â Í∏∞Îä•

### 4.1 TossPaymentsService ÌôïÏû•
**ÌååÏùº ÏúÑÏπò**: `apps/api-server/src/services/TossPaymentsService.ts` (Í∏∞Ï°¥ ÌååÏùºÏóê Ï∂îÍ∞Ä)

```typescript
// Í∏∞Ï°¥ ÏΩîÎìúÏóê Ï∂îÍ∞ÄÌï† Î©îÏÑúÎìúÎì§

// Ï†ïÍ∏∞Í≤∞Ï†ú Îì±Î°ù
async createBillingKey(customerId: string, cardInfo: any) {
  const url = `${this.baseUrl}/billing/authorizations/card`;
  
  try {
    const response = await axios.post(url, {
      customerKey: customerId,
      cardNumber: cardInfo.number,
      cardExpirationYear: cardInfo.expirationYear,
      cardExpirationMonth: cardInfo.expirationMonth,
      cardPassword: cardInfo.password,
      customerIdentityNumber: cardInfo.identityNumber,
      customerName: cardInfo.customerName,
      customerEmail: cardInfo.customerEmail
    }, {
      headers: {
        Authorization: `Basic ${Buffer.from(this.secretKey + ':').toString('base64')}`,
        'Content-Type': 'application/json'
      }
    });

    // ÎπåÎßÅÌÇ§ Ï†ÄÏû•
    await this.saveBillingKey(customerId, response.data.billingKey);
    
    return response.data;
  } catch (error) {
    logger.error('Failed to create billing key:', error);
    throw error;
  }
}

// Ï†ïÍ∏∞Í≤∞Ï†ú Ïã§Ìñâ
async executeSubscriptionPayment(subscriptionId: string) {
  const subscription = await this.getSubscription(subscriptionId);
  
  const url = `${this.baseUrl}/billing/${subscription.billingKey}`;
  
  try {
    const response = await axios.post(url, {
      customerKey: subscription.customerId,
      amount: subscription.amount,
      orderId: `SUB-${Date.now()}`,
      orderName: subscription.productName,
      customerEmail: subscription.customerEmail,
      customerName: subscription.customerName,
      taxFreeAmount: 0
    }, {
      headers: {
        Authorization: `Basic ${Buffer.from(this.secretKey + ':').toString('base64')}`,
        'Content-Type': 'application/json'
      }
    });

    // Í≤∞Ï†ú Í∏∞Î°ù Ï†ÄÏû•
    await this.recordSubscriptionPayment(subscription, response.data);
    
    return response.data;
  } catch (error) {
    logger.error('Failed to execute subscription payment:', error);
    
    // Ïã§Ìå® Ïãú Ïû¨ÏãúÎèÑ Î°úÏßÅ
    await this.scheduleRetry(subscriptionId);
    
    throw error;
  }
}

// Î∂ÄÎ∂Ñ Ï∑®ÏÜå
async partialCancel(paymentKey: string, cancelAmount: number, cancelReason: string) {
  const url = `${this.baseUrl}/payments/${paymentKey}/cancel`;
  
  try {
    const payment = await this.getPayment(paymentKey);
    
    if (payment.canceledAmount + cancelAmount > payment.totalAmount) {
      throw new BadRequestException('Ï∑®ÏÜå Í∏àÏï°Ïù¥ Í≤∞Ï†ú Í∏àÏï°ÏùÑ Ï¥àÍ≥ºÌï©ÎãàÎã§');
    }

    const response = await axios.post(url, {
      cancelAmount,
      cancelReason,
      taxFreeAmount: 0,
      refundReceiveAccount: payment.virtualAccount // Í∞ÄÏÉÅÍ≥ÑÏ¢å ÌôòÎ∂à Ïãú
    }, {
      headers: {
        Authorization: `Basic ${Buffer.from(this.secretKey + ':').toString('base64')}`,
        'Content-Type': 'application/json'
      }
    });

    // Î∂ÄÎ∂Ñ Ï∑®ÏÜå Í∏∞Î°ù
    await this.recordPartialCancel(paymentKey, cancelAmount, cancelReason);
    
    return response.data;
  } catch (error) {
    logger.error('Failed to partial cancel:', error);
    throw error;
  }
}

// ÏóêÏä§ÌÅ¨Î°ú Íµ¨Îß§ ÌôïÏ†ï
async confirmEscrow(paymentKey: string) {
  const url = `${this.baseUrl}/payments/${paymentKey}/escrow/confirm`;
  
  try {
    const response = await axios.post(url, {}, {
      headers: {
        Authorization: `Basic ${Buffer.from(this.secretKey + ':').toString('base64')}`,
        'Content-Type': 'application/json'
      }
    });

    return response.data;
  } catch (error) {
    logger.error('Failed to confirm escrow:', error);
    throw error;
  }
}

// ÌòÑÍ∏àÏòÅÏàòÏ¶ù Î∞úÍ∏â
async issueCashReceipt(amount: number, type: 'personal' | 'business', identifier: string) {
  const url = `${this.baseUrl}/cash-receipts`;
  
  try {
    const response = await axios.post(url, {
      amount,
      orderId: `CASH-${Date.now()}`,
      orderName: 'ÌòÑÍ∏àÏòÅÏàòÏ¶ù Î∞úÍ∏â',
      type: type === 'personal' ? 'ÏÜåÎìùÍ≥µÏ†ú' : 'ÏßÄÏ∂úÏ¶ùÎπô',
      registrationNumber: identifier,
      taxFreeAmount: 0
    }, {
      headers: {
        Authorization: `Basic ${Buffer.from(this.secretKey + ':').toString('base64')}`,
        'Content-Type': 'application/json'
      }
    });

    return response.data;
  } catch (error) {
    logger.error('Failed to issue cash receipt:', error);
    throw error;
  }
}

// Í≤∞Ï†ú Ï†ïÏÇ∞ Ï°∞Ìöå
async getSettlements(date: string) {
  const url = `${this.baseUrl}/settlements?date=${date}`;
  
  try {
    const response = await axios.get(url, {
      headers: {
        Authorization: `Basic ${Buffer.from(this.secretKey + ':').toString('base64')}`
      }
    });

    return response.data;
  } catch (error) {
    logger.error('Failed to get settlements:', error);
    throw error;
  }
}

// Ï†ïÍ∏∞Í≤∞Ï†ú Ïä§ÏºÄÏ§ÑÎü¨ (Îß§Ïùº Ïã§Ìñâ)
@Cron(CronExpression.EVERY_DAY_AT_2AM)
async processSubscriptions() {
  const today = new Date();
  const subscriptions = await this.getActiveSubscriptions(today);
  
  for (const subscription of subscriptions) {
    try {
      await this.executeSubscriptionPayment(subscription.id);
      logger.info(`Subscription payment successful: ${subscription.id}`);
    } catch (error) {
      logger.error(`Subscription payment failed: ${subscription.id}`, error);
      
      // Ïã§Ìå® ÏïåÎ¶º Ï†ÑÏÜ°
      await this.sendPaymentFailureNotification(subscription);
    }
  }
}
```

## üîß Phase 5: ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò ÏÉùÏÑ±

```bash
# Ïù∏Î≤§ÌÜ†Î¶¨ ÌÖåÏù¥Î∏î ÏÉùÏÑ±
cd apps/api-server
npm run migration:generate -- -n CreateInventoryTables

# Î∂ÑÏÑù Í¥ÄÎ†® Ïù∏Îç±Ïä§ Ï∂îÍ∞Ä
npm run migration:generate -- -n AddAnalyticsIndexes

# ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò Ïã§Ìñâ
npm run migration:run
```

## üîß Phase 6: ÌôòÍ≤Ω Î≥ÄÏàò ÏÑ§Ï†ï

**.env ÌååÏùºÏóê Ï∂îÍ∞Ä**
```env
# Toss Payments
TOSS_CLIENT_KEY=test_ck_...
TOSS_SECRET_KEY=test_sk_...
TOSS_WEBHOOK_SECRET=...

# Analytics Cache
REDIS_HOST=localhost
REDIS_PORT=6379
CACHE_TTL=300

# Inventory Settings
AUTO_REORDER_ENABLED=true
DEFAULT_LEAD_TIME=7
REORDER_CHECK_INTERVAL=3600000
LOW_STOCK_THRESHOLD=20
```

## üìä ÌÖåÏä§Ìä∏ ÏãúÎÇòÎ¶¨Ïò§

### 1. Ïû¨Í≥† Í¥ÄÎ¶¨ ÌÖåÏä§Ìä∏
```bash
# Ïû¨Í≥† Ï°∞Ï†ï
curl -X POST http://localhost:3001/api/inventory/adjust \
  -H "Authorization: Bearer ${JWT_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "inventoryId": "xxx",
    "type": "increase",
    "quantity": 100,
    "reason": "Ïã†Í∑ú ÏûÖÍ≥†"
  }'

# Ïû¨Í≥† ÏïåÎ¶º Ï°∞Ìöå
curl -X GET http://localhost:3001/api/inventory/alerts?severity=critical \
  -H "Authorization: Bearer ${JWT_TOKEN}"

# Ïû¨Í≥† ÏòàÏ∏°
curl -X GET http://localhost:3001/api/inventory/{id}/forecast?days=30 \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

### 2. Î∂ÑÏÑù API ÌÖåÏä§Ìä∏
```bash
# ÎåÄÏãúÎ≥¥Îìú ÌÜµÍ≥Ñ
curl -X GET http://localhost:3001/api/analytics/ecommerce?period=month \
  -H "Authorization: Bearer ${JWT_TOKEN}"

# Î≥¥Í≥†ÏÑú ÏÉùÏÑ±
curl -X GET http://localhost:3001/api/analytics/report?type=sales&period=month&format=pdf \
  -H "Authorization: Bearer ${JWT_TOKEN}"
```

### 3. Toss Payments Í≥†Í∏â Í∏∞Îä• ÌÖåÏä§Ìä∏
```bash
# Ï†ïÍ∏∞Í≤∞Ï†ú Îì±Î°ù
curl -X POST http://localhost:3001/api/payments/subscription \
  -H "Authorization: Bearer ${JWT_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "customerId": "CUSTOMER123",
    "productId": "PROD456",
    "amount": 9900,
    "interval": "monthly"
  }'

# Î∂ÄÎ∂Ñ Ï∑®ÏÜå
curl -X POST http://localhost:3001/api/payments/{paymentKey}/partial-cancel \
  -H "Authorization: Bearer ${JWT_TOKEN}" \
  -H "Content-Type: application/json" \
  -d '{
    "cancelAmount": 5000,
    "cancelReason": "Î∂ÄÎ∂Ñ ÌôòÎ∂à ÏöîÏ≤≠"
  }'
```

## üöÄ Î∞∞Ìè¨ Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

1. **Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò**
   - [ ] Inventory ÌÖåÏù¥Î∏î ÏÉùÏÑ±
   - [ ] Î∂ÑÏÑù Ïù∏Îç±Ïä§ Ï∂îÍ∞Ä
   - [ ] Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÎßàÏù¥Í∑∏Î†àÏù¥ÏÖò

2. **ÌôòÍ≤Ω Î≥ÄÏàò ÌôïÏù∏**
   - [ ] Toss Payments ÌÇ§ ÏÑ§Ï†ï
   - [ ] Redis Ï∫êÏãú ÏÑ§Ï†ï
   - [ ] Ïû¨Í≥† Í¥ÄÎ¶¨ ÏÑ§Ï†ï

3. **ÌÅ¨Î°† ÏûëÏóÖ ÌôúÏÑ±Ìôî**
   - [ ] Ïû¨Í≥† ÏÉÅÌÉú ÌôïÏù∏ (Îß§ÏãúÍ∞Ñ)
   - [ ] Ï†ïÍ∏∞Í≤∞Ï†ú Ï≤òÎ¶¨ (Îß§Ïùº ÏÉàÎ≤Ω 2Ïãú)
   - [ ] Î≥¥Í≥†ÏÑú ÏÉùÏÑ± (Îß§Ï£º/Îß§Ïõî)

4. **Î™®ÎãàÌÑ∞ÎßÅ ÏÑ§Ï†ï**
   - [ ] Ïû¨Í≥† ÏïåÎ¶º Ïù¥Î©îÏùº
   - [ ] Í≤∞Ï†ú Ïã§Ìå® ÏïåÎ¶º
   - [ ] ÏÑ±Îä• Î©îÌä∏Î¶≠

5. **ÏÑ±Îä• ÏµúÏ†ÅÌôî**
   - [ ] ÏøºÎ¶¨ ÏµúÏ†ÅÌôî
   - [ ] Ï∫êÏã± Ï†ÑÎûµ
   - [ ] Ïù∏Îç±Ïä§ Í≤ÄÏ¶ù

## üìå Ï£ºÏùòÏÇ¨Ìï≠

1. **Ïû¨Í≥† Í¥ÄÎ¶¨**
   - ÎèôÏãúÏÑ± Ï†úÏñ¥ ÌïÑÏàò (Ìä∏ÎûúÏû≠ÏÖò)
   - Ïû¨Í≥† ÏòàÏïΩ/Ï∞®Í∞ê Ïãú Îç∞Ïù¥ÌÑ∞ Ï†ïÌï©ÏÑ± Î≥¥Ïû•
   - Ïû¨Ï£ºÎ¨∏ Ï§ëÎ≥µ Î∞©ÏßÄ

2. **Î∂ÑÏÑù Îç∞Ïù¥ÌÑ∞**
   - ÎåÄÏö©Îüâ Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨ Ïãú ÌéòÏù¥Ïßï
   - Ï∫êÏãú Ï†ÅÍ∑π ÌôúÏö©
   - Î∞±Í∑∏ÎùºÏö¥Îìú ÏûëÏóÖÏúºÎ°ú Ï≤òÎ¶¨

3. **Toss Payments**
   - ÌÖåÏä§Ìä∏/Ïö¥ÏòÅ ÌÇ§ Î∂ÑÎ¶¨
   - ÏõπÌõÖ Í≤ÄÏ¶ù ÌïÑÏàò
   - Ïã§Ìå® Ïãú Ïû¨ÏãúÎèÑ Î°úÏßÅ

---

Ïù¥ ÏûëÏóÖ ÏßÄÏãúÏÑúÎ•º API ÏÑúÎ≤ÑÏùò Claude CodeÏóêÍ≤å Ï†ÑÎã¨ÌïòÏó¨ E-commerce ÏãúÏä§ÌÖúÏùò Î∞±ÏóîÎìú Íµ¨ÌòÑÏùÑ ÏôÑÎ£åÌïòÏÑ∏Ïöî.
ÏòàÏÉÅ ÏûëÏóÖ ÏãúÍ∞Ñ: 8-10ÏãúÍ∞Ñ