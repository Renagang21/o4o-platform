{
  "version": 3,
  "sources": ["../../../../node_modules/@tannin/postfix/index.js", "../../../../node_modules/@tannin/evaluate/index.js", "../../../../node_modules/@tannin/compile/index.js", "../../../../node_modules/@tannin/plural-forms/index.js", "../../../../node_modules/tannin/index.js"],
  "sourcesContent": ["var PRECEDENCE, OPENERS, TERMINATORS, PATTERN;\n\n/**\n * Operator precedence mapping.\n *\n * @type {Object}\n */\nPRECEDENCE = {\n\t'(': 9,\n\t'!': 8,\n\t'*': 7,\n\t'/': 7,\n\t'%': 7,\n\t'+': 6,\n\t'-': 6,\n\t'<': 5,\n\t'<=': 5,\n\t'>': 5,\n\t'>=': 5,\n\t'==': 4,\n\t'!=': 4,\n\t'&&': 3,\n\t'||': 2,\n\t'?': 1,\n\t'?:': 1,\n};\n\n/**\n * Characters which signal pair opening, to be terminated by terminators.\n *\n * @type {string[]}\n */\nOPENERS = [ '(', '?' ];\n\n/**\n * Characters which signal pair termination, the value an array with the\n * opener as its first member. The second member is an optional operator\n * replacement to push to the stack.\n *\n * @type {string[]}\n */\nTERMINATORS = {\n\t')': [ '(' ],\n\t':': [ '?', '?:' ],\n};\n\n/**\n * Pattern matching operators and openers.\n *\n * @type {RegExp}\n */\nPATTERN = /<=|>=|==|!=|&&|\\|\\||\\?:|\\(|!|\\*|\\/|%|\\+|-|<|>|\\?|\\)|:/;\n\n/**\n * Given a C expression, returns the equivalent postfix (Reverse Polish)\n * notation terms as an array.\n *\n * If a postfix string is desired, simply `.join( ' ' )` the result.\n *\n * @example\n *\n * ```js\n * import postfix from '@tannin/postfix';\n *\n * postfix( 'n > 1' );\n * // ⇒ [ 'n', '1', '>' ]\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {string[]} Postfix terms.\n */\nexport default function postfix( expression ) {\n\tvar terms = [],\n\t\tstack = [],\n\t\tmatch, operator, term, element;\n\n\twhile ( ( match = expression.match( PATTERN ) ) ) {\n\t\toperator = match[ 0 ];\n\n\t\t// Term is the string preceding the operator match. It may contain\n\t\t// whitespace, and may be empty (if operator is at beginning).\n\t\tterm = expression.substr( 0, match.index ).trim();\n\t\tif ( term ) {\n\t\t\tterms.push( term );\n\t\t}\n\n\t\twhile ( ( element = stack.pop() ) ) {\n\t\t\tif ( TERMINATORS[ operator ] ) {\n\t\t\t\tif ( TERMINATORS[ operator ][ 0 ] === element ) {\n\t\t\t\t\t// Substitution works here under assumption that because\n\t\t\t\t\t// the assigned operator will no longer be a terminator, it\n\t\t\t\t\t// will be pushed to the stack during the condition below.\n\t\t\t\t\toperator = TERMINATORS[ operator ][ 1 ] || operator;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if ( OPENERS.indexOf( element ) >= 0 || PRECEDENCE[ element ] < PRECEDENCE[ operator ] ) {\n\t\t\t\t// Push to stack if either an opener or when pop reveals an\n\t\t\t\t// element of lower precedence.\n\t\t\t\tstack.push( element );\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// For each popped from stack, push to terms.\n\t\t\tterms.push( element );\n\t\t}\n\n\t\tif ( ! TERMINATORS[ operator ] ) {\n\t\t\tstack.push( operator );\n\t\t}\n\n\t\t// Slice matched fragment from expression to continue match.\n\t\texpression = expression.substr( match.index + operator.length );\n\t}\n\n\t// Push remainder of operand, if exists, to terms.\n\texpression = expression.trim();\n\tif ( expression ) {\n\t\tterms.push( expression );\n\t}\n\n\t// Pop remaining items from stack into terms.\n\treturn terms.concat( stack.reverse() );\n}\n", "/**\n * Operator callback functions.\n *\n * @type {Object}\n */\nvar OPERATORS = {\n\t'!': function( a ) {\n\t\treturn ! a;\n\t},\n\t'*': function( a, b ) {\n\t\treturn a * b;\n\t},\n\t'/': function( a, b ) {\n\t\treturn a / b;\n\t},\n\t'%': function( a, b ) {\n\t\treturn a % b;\n\t},\n\t'+': function( a, b ) {\n\t\treturn a + b;\n\t},\n\t'-': function( a, b ) {\n\t\treturn a - b;\n\t},\n\t'<': function( a, b ) {\n\t\treturn a < b;\n\t},\n\t'<=': function( a, b ) {\n\t\treturn a <= b;\n\t},\n\t'>': function( a, b ) {\n\t\treturn a > b;\n\t},\n\t'>=': function( a, b ) {\n\t\treturn a >= b;\n\t},\n\t'==': function( a, b ) {\n\t\treturn a === b;\n\t},\n\t'!=': function( a, b ) {\n\t\treturn a !== b;\n\t},\n\t'&&': function( a, b ) {\n\t\treturn a && b;\n\t},\n\t'||': function( a, b ) {\n\t\treturn a || b;\n\t},\n\t'?:': function( a, b, c ) {\n\t\tif ( a ) {\n\t\t\tthrow b;\n\t\t}\n\n\t\treturn c;\n\t},\n};\n\n/**\n * Given an array of postfix terms and operand variables, returns the result of\n * the postfix evaluation.\n *\n * @example\n *\n * ```js\n * import evaluate from '@tannin/evaluate';\n *\n * // 3 + 4 * 5 / 6 ⇒ '3 4 5 * 6 / +'\n * const terms = [ '3', '4', '5', '*', '6', '/', '+' ];\n *\n * evaluate( terms, {} );\n * // ⇒ 6.333333333333334\n * ```\n *\n * @param {string[]} postfix   Postfix terms.\n * @param {Object}   variables Operand variables.\n *\n * @return {*} Result of evaluation.\n */\nexport default function evaluate( postfix, variables ) {\n\tvar stack = [],\n\t\ti, j, args, getOperatorResult, term, value;\n\n\tfor ( i = 0; i < postfix.length; i++ ) {\n\t\tterm = postfix[ i ];\n\n\t\tgetOperatorResult = OPERATORS[ term ];\n\t\tif ( getOperatorResult ) {\n\t\t\t// Pop from stack by number of function arguments.\n\t\t\tj = getOperatorResult.length;\n\t\t\targs = Array( j );\n\t\t\twhile ( j-- ) {\n\t\t\t\targs[ j ] = stack.pop();\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tvalue = getOperatorResult.apply( null, args );\n\t\t\t} catch ( earlyReturn ) {\n\t\t\t\treturn earlyReturn;\n\t\t\t}\n\t\t} else if ( variables.hasOwnProperty( term ) ) {\n\t\t\tvalue = variables[ term ];\n\t\t} else {\n\t\t\tvalue = +term;\n\t\t}\n\n\t\tstack.push( value );\n\t}\n\n\treturn stack[ 0 ];\n}\n", "import postfix from '@tannin/postfix';\nimport evaluate from '@tannin/evaluate';\n\n/**\n * Given a C expression, returns a function which can be called to evaluate its\n * result.\n *\n * @example\n *\n * ```js\n * import compile from '@tannin/compile';\n *\n * const evaluate = compile( 'n > 1' );\n *\n * evaluate( { n: 2 } );\n * // ⇒ true\n * ```\n *\n * @param {string} expression C expression.\n *\n * @return {(variables?:{[variable:string]:*})=>*} Compiled evaluator.\n */\nexport default function compile( expression ) {\n\tvar terms = postfix( expression );\n\n\treturn function( variables ) {\n\t\treturn evaluate( terms, variables );\n\t};\n}\n", "import compile from '@tannin/compile';\n\n/**\n * Given a C expression, returns a function which, when called with a value,\n * evaluates the result with the value assumed to be the \"n\" variable of the\n * expression. The result will be coerced to its numeric equivalent.\n *\n * @param {string} expression C expression.\n *\n * @return {Function} Evaluator function.\n */\nexport default function pluralForms( expression ) {\n\tvar evaluate = compile( expression );\n\n\treturn function( n ) {\n\t\treturn +evaluate( { n: n } );\n\t};\n}\n", "import pluralForms from '@tannin/plural-forms';\n\n/**\n * Tannin constructor options.\n *\n * @typedef {Object} TanninOptions\n *\n * @property {string}   [contextDelimiter] Joiner in string lookup with context.\n * @property {Function} [onMissingKey]     Callback to invoke when key missing.\n */\n\n/**\n * Domain metadata.\n *\n * @typedef {Object} TanninDomainMetadata\n *\n * @property {string}            [domain]       Domain name.\n * @property {string}            [lang]         Language code.\n * @property {(string|Function)} [plural_forms] Plural forms expression or\n *                                              function evaluator.\n */\n\n/**\n * Domain translation pair respectively representing the singular and plural\n * translation.\n *\n * @typedef {[string,string]} TanninTranslation\n */\n\n/**\n * Locale data domain. The key is used as reference for lookup, the value an\n * array of two string entries respectively representing the singular and plural\n * translation.\n *\n * @typedef {{[key:string]:TanninDomainMetadata|TanninTranslation,'':TanninDomainMetadata|TanninTranslation}} TanninLocaleDomain\n */\n\n/**\n * Jed-formatted locale data.\n *\n * @see http://messageformat.github.io/Jed/\n *\n * @typedef {{[domain:string]:TanninLocaleDomain}} TanninLocaleData\n */\n\n/**\n * Default Tannin constructor options.\n *\n * @type {TanninOptions}\n */\nvar DEFAULT_OPTIONS = {\n\tcontextDelimiter: '\\u0004',\n\tonMissingKey: null,\n};\n\n/**\n * Given a specific locale data's config `plural_forms` value, returns the\n * expression.\n *\n * @example\n *\n * ```\n * getPluralExpression( 'nplurals=2; plural=(n != 1);' ) === '(n != 1)'\n * ```\n *\n * @param {string} pf Locale data plural forms.\n *\n * @return {string} Plural forms expression.\n */\nfunction getPluralExpression( pf ) {\n\tvar parts, i, part;\n\n\tparts = pf.split( ';' );\n\n\tfor ( i = 0; i < parts.length; i++ ) {\n\t\tpart = parts[ i ].trim();\n\t\tif ( part.indexOf( 'plural=' ) === 0 ) {\n\t\t\treturn part.substr( 7 );\n\t\t}\n\t}\n}\n\n/**\n * Tannin constructor.\n *\n * @class\n *\n * @param {TanninLocaleData} data      Jed-formatted locale data.\n * @param {TanninOptions}    [options] Tannin options.\n */\nexport default function Tannin( data, options ) {\n\tvar key;\n\n\t/**\n\t * Jed-formatted locale data.\n\t *\n\t * @name Tannin#data\n\t * @type {TanninLocaleData}\n\t */\n\tthis.data = data;\n\n\t/**\n\t * Plural forms function cache, keyed by plural forms string.\n\t *\n\t * @name Tannin#pluralForms\n\t * @type {Object<string,Function>}\n\t */\n\tthis.pluralForms = {};\n\n\t/**\n\t * Effective options for instance, including defaults.\n\t *\n\t * @name Tannin#options\n\t * @type {TanninOptions}\n\t */\n\tthis.options = {};\n\n\tfor ( key in DEFAULT_OPTIONS ) {\n\t\tthis.options[ key ] = options !== undefined && key in options\n\t\t\t? options[ key ]\n\t\t\t: DEFAULT_OPTIONS[ key ];\n\t}\n}\n\n/**\n * Returns the plural form index for the given domain and value.\n *\n * @param {string} domain Domain on which to calculate plural form.\n * @param {number} n      Value for which plural form is to be calculated.\n *\n * @return {number} Plural form index.\n */\nTannin.prototype.getPluralForm = function( domain, n ) {\n\tvar getPluralForm = this.pluralForms[ domain ],\n\t\tconfig, plural, pf;\n\n\tif ( ! getPluralForm ) {\n\t\tconfig = this.data[ domain ][ '' ];\n\n\t\tpf = (\n\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t// @ts-ignore\n\t\t\tconfig.plural_forms\n\t\t);\n\n\t\tif ( typeof pf !== 'function' ) {\n\t\t\tplural = getPluralExpression(\n\t\t\t\tconfig[ 'Plural-Forms' ] ||\n\t\t\t\tconfig[ 'plural-forms' ] ||\n\t\t\t\t// Ignore reason: As known, there's no way to document the empty\n\t\t\t\t// string property on a key to guarantee this as metadata.\n\t\t\t\t// @ts-ignore\n\t\t\t\tconfig.plural_forms\n\t\t\t);\n\n\t\t\tpf = pluralForms( plural );\n\t\t}\n\n\t\tgetPluralForm = this.pluralForms[ domain ] = pf;\n\t}\n\n\treturn getPluralForm( n );\n};\n\n/**\n * Translate a string.\n *\n * @param {string}      domain   Translation domain.\n * @param {string|void} context  Context distinguishing terms of the same name.\n * @param {string}      singular Primary key for translation lookup.\n * @param {string=}     plural   Fallback value used for non-zero plural\n *                               form index.\n * @param {number=}     n        Value to use in calculating plural form.\n *\n * @return {string} Translated string.\n */\nTannin.prototype.dcnpgettext = function( domain, context, singular, plural, n ) {\n\tvar index, key, entry;\n\n\tif ( n === undefined ) {\n\t\t// Default to singular.\n\t\tindex = 0;\n\t} else {\n\t\t// Find index by evaluating plural form for value.\n\t\tindex = this.getPluralForm( domain, n );\n\t}\n\n\tkey = singular;\n\n\t// If provided, context is prepended to key with delimiter.\n\tif ( context ) {\n\t\tkey = context + this.options.contextDelimiter + singular;\n\t}\n\n\tentry = this.data[ domain ][ key ];\n\n\t// Verify not only that entry exists, but that the intended index is within\n\t// range and non-empty.\n\tif ( entry && entry[ index ] ) {\n\t\treturn entry[ index ];\n\t}\n\n\tif ( this.options.onMissingKey ) {\n\t\tthis.options.onMissingKey( singular, domain );\n\t}\n\n\t// If entry not found, fall back to singular vs. plural with zero index\n\t// representing the singular value.\n\treturn index === 0 ? singular : plural;\n};\n"],
  "mappings": "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",
  "names": ["postfix", "evaluate"]
}
