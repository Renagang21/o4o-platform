{
  "version": 3,
  "sources": ["../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/validateNamespace.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/validateHookName.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/createAddHook.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/createRemoveHook.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/createHasHook.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/createRunHook.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/createCurrentHook.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/createDoingHook.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/createDidHook.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/createHooks.ts", "../../../../node_modules/@wordpress/hooks/build-module/@wordpress/hooks/src/index.ts", "../../../../node_modules/@tannin/sprintf/src/index.js"],
  "sourcesContent": ["/**\n * Validate a namespace string.\n *\n * @param namespace The namespace to validate - should take the form\n *                  `vendor/plugin/function`.\n *\n * @return Whether the namespace is valid.\n */\nfunction validateNamespace( namespace: string ): boolean {\n\tif ( 'string' !== typeof namespace || '' === namespace ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'The namespace must be a non-empty string.' );\n\t\treturn false;\n\t}\n\n\tif ( ! /^[a-zA-Z][a-zA-Z0-9_.\\-\\/]*$/.test( namespace ) ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error(\n\t\t\t'The namespace can only contain numbers, letters, dashes, periods, underscores and slashes.'\n\t\t);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport default validateNamespace;\n", "/**\n * Validate a hookName string.\n *\n * @param hookName The hook name to validate. Should be a non empty string containing\n *                 only numbers, letters, dashes, periods and underscores. Also,\n *                 the hook name cannot begin with `__`.\n *\n * @return Whether the hook name is valid.\n */\nfunction validateHookName( hookName: string ): boolean {\n\tif ( 'string' !== typeof hookName || '' === hookName ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'The hook name must be a non-empty string.' );\n\t\treturn false;\n\t}\n\n\tif ( /^__/.test( hookName ) ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error( 'The hook name cannot begin with `__`.' );\n\t\treturn false;\n\t}\n\n\tif ( ! /^[a-zA-Z][a-zA-Z0-9_.-]*$/.test( hookName ) ) {\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.error(\n\t\t\t'The hook name can only contain numbers, letters, dashes, periods and underscores.'\n\t\t);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nexport default validateHookName;\n", "/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace';\nimport validateHookName from './validateHookName';\nimport type { Callback, Hooks, StoreKey } from '.';\nimport type { Handler, HookInfo } from './types';\n\n/**\n *\n * Adds the hook to the appropriate hooks container.\n */\nexport type AddHook = (\n\t/**\n\t * Name of hook to add\n\t */\n\thookName: string,\n\t/**\n\t * The unique namespace identifying the callback in the form.\n\t */\n\tnamespace: string,\n\t/**\n\t * Function to call when the hook is run.\n\t */\n\tcallback: Callback,\n\t/**\n\t * Priority of this hook\n\t */\n\tpriority?: number\n) => void;\n\n/**\n * Returns a function which, when invoked, will add a hook.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return  Function that adds a new hook.\n */\nfunction createAddHook( hooks: Hooks, storeKey: StoreKey ): AddHook {\n\treturn function addHook( hookName, namespace, callback, priority = 10 ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! validateHookName( hookName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! validateNamespace( namespace ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( 'function' !== typeof callback ) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error( 'The hook callback must be a function.' );\n\t\t\treturn;\n\t\t}\n\n\t\t// Validate numeric priority\n\t\tif ( 'number' !== typeof priority ) {\n\t\t\t// eslint-disable-next-line no-console\n\t\t\tconsole.error(\n\t\t\t\t'If specified, the hook priority must be a number.'\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\tconst handler: Handler = { callback, priority, namespace };\n\n\t\tif ( hooksStore[ hookName ] ) {\n\t\t\t// Find the correct insert index of the new hook.\n\t\t\tconst handlers = hooksStore[ hookName ].handlers;\n\n\t\t\tlet i: number;\n\t\t\tfor ( i = handlers.length; i > 0; i-- ) {\n\t\t\t\tif ( priority >= handlers[ i - 1 ].priority ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( i === handlers.length ) {\n\t\t\t\t// If append, operate via direct assignment.\n\t\t\t\thandlers[ i ] = handler;\n\t\t\t} else {\n\t\t\t\t// Otherwise, insert before index via splice.\n\t\t\t\thandlers.splice( i, 0, handler );\n\t\t\t}\n\n\t\t\t// We may also be currently executing this hook.  If the callback\n\t\t\t// we're adding would come after the current callback, there's no\n\t\t\t// problem; otherwise we need to increase the execution index of\n\t\t\t// any other runs by 1 to account for the added element.\n\t\t\thooksStore.__current.forEach( ( hookInfo: HookInfo ) => {\n\t\t\t\tif (\n\t\t\t\t\thookInfo.name === hookName &&\n\t\t\t\t\thookInfo.currentIndex >= i\n\t\t\t\t) {\n\t\t\t\t\thookInfo.currentIndex++;\n\t\t\t\t}\n\t\t\t} );\n\t\t} else {\n\t\t\t// This is the first hook of its type.\n\t\t\thooksStore[ hookName ] = {\n\t\t\t\thandlers: [ handler ],\n\t\t\t\truns: 0,\n\t\t\t};\n\t\t}\n\n\t\tif ( hookName !== 'hookAdded' ) {\n\t\t\thooks.doAction(\n\t\t\t\t'hookAdded',\n\t\t\t\thookName,\n\t\t\t\tnamespace,\n\t\t\t\tcallback,\n\t\t\t\tpriority\n\t\t\t);\n\t\t}\n\t};\n}\n\nexport default createAddHook;\n", "/**\n * Internal dependencies\n */\nimport validateNamespace from './validateNamespace';\nimport validateHookName from './validateHookName';\nimport type { Hooks, StoreKey } from './types';\n\n/**\n * Removes the specified callback (or all callbacks) from the hook with a given hookName\n * and namespace.\n */\nexport type RemoveHook = (\n\t/**\n\t * The name of the hook to modify.\n\t */\n\thookName: string,\n\t/**\n\t * The unique namespace identifying the callback in the form `vendor/plugin/function`.\n\t */\n\tnamespace: string\n) => number | undefined;\n\n/**\n * Returns a function which, when invoked, will remove a specified hook or all\n * hooks by the given name.\n *\n * @param hooks             Hooks instance.\n * @param storeKey\n * @param [removeAll=false] Whether to remove all callbacks for a hookName,\n *                          without regard to namespace. Used to create\n *                          `removeAll*` functions.\n *\n * @return Function that removes hooks.\n */\nfunction createRemoveHook(\n\thooks: Hooks,\n\tstoreKey: StoreKey,\n\tremoveAll: boolean = false\n): RemoveHook {\n\treturn function removeHook( hookName, namespace ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! validateHookName( hookName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! removeAll && ! validateNamespace( namespace ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Bail if no hooks exist by this name.\n\t\tif ( ! hooksStore[ hookName ] ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet handlersRemoved = 0;\n\n\t\tif ( removeAll ) {\n\t\t\thandlersRemoved = hooksStore[ hookName ].handlers.length;\n\t\t\thooksStore[ hookName ] = {\n\t\t\t\truns: hooksStore[ hookName ].runs,\n\t\t\t\thandlers: [],\n\t\t\t};\n\t\t} else {\n\t\t\t// Try to find the specified callback to remove.\n\t\t\tconst handlers = hooksStore[ hookName ].handlers;\n\t\t\tfor ( let i = handlers.length - 1; i >= 0; i-- ) {\n\t\t\t\tif ( handlers[ i ].namespace === namespace ) {\n\t\t\t\t\thandlers.splice( i, 1 );\n\t\t\t\t\thandlersRemoved++;\n\t\t\t\t\t// This callback may also be part of a hook that is\n\t\t\t\t\t// currently executing.  If the callback we're removing\n\t\t\t\t\t// comes after the current callback, there's no problem;\n\t\t\t\t\t// otherwise we need to decrease the execution index of any\n\t\t\t\t\t// other runs by 1 to account for the removed element.\n\t\t\t\t\thooksStore.__current.forEach( ( hookInfo ) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\thookInfo.name === hookName &&\n\t\t\t\t\t\t\thookInfo.currentIndex >= i\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\thookInfo.currentIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( hookName !== 'hookRemoved' ) {\n\t\t\thooks.doAction( 'hookRemoved', hookName, namespace );\n\t\t}\n\n\t\treturn handlersRemoved;\n\t};\n}\n\nexport default createRemoveHook;\n", "/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n/**\n *\n * Returns whether any handlers are attached for the given hookName and optional namespace.\n */\nexport type HasHook = (\n\t/**\n\t * The name of the hook to check for.\n\t */\n\thookname: string,\n\t/**\n\t * The unique namespace identifying the callback in the form `vendor/plugin/function`.\n\t */\n\tnamespace?: string\n) => boolean;\n\n/**\n * Returns a function which, when invoked, will return whether any handlers are\n * attached to a particular hook.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return  Function that returns whether any handlers are\n *                   attached to a particular hook and optional namespace.\n */\nfunction createHasHook( hooks: Hooks, storeKey: StoreKey ): HasHook {\n\treturn function hasHook( hookName, namespace ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\t// Use the namespace if provided.\n\t\tif ( 'undefined' !== typeof namespace ) {\n\t\t\treturn (\n\t\t\t\thookName in hooksStore &&\n\t\t\t\thooksStore[ hookName ].handlers.some(\n\t\t\t\t\t( hook ) => hook.namespace === namespace\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn hookName in hooksStore;\n\t};\n}\n\nexport default createHasHook;\n", "/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n\nexport type RunHook = (\n\thookName: string,\n\t...args: unknown[]\n) => undefined | unknown;\n\n/**\n * Returns a function which, when invoked, will execute all callbacks\n * registered to a hook of the specified type, optionally returning the final\n * value of the call chain.\n *\n * @param hooks          Hooks instance.\n * @param storeKey\n * @param returnFirstArg Whether each hook callback is expected to return its first argument.\n * @param async          Whether the hook callback should be run asynchronously\n *\n * @return Function that runs hook callbacks.\n */\nfunction createRunHook(\n\thooks: Hooks,\n\tstoreKey: StoreKey,\n\treturnFirstArg: boolean,\n\tasync: boolean\n): RunHook {\n\treturn function runHook( hookName, ...args ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! hooksStore[ hookName ] ) {\n\t\t\thooksStore[ hookName ] = {\n\t\t\t\thandlers: [],\n\t\t\t\truns: 0,\n\t\t\t};\n\t\t}\n\n\t\thooksStore[ hookName ].runs++;\n\n\t\tconst handlers = hooksStore[ hookName ].handlers;\n\n\t\t// The following code is stripped from production builds.\n\t\tif ( 'production' !== process.env.NODE_ENV ) {\n\t\t\t// Handle any 'all' hooks registered.\n\t\t\tif ( 'hookAdded' !== hookName && hooksStore.all ) {\n\t\t\t\thandlers.push( ...hooksStore.all.handlers );\n\t\t\t}\n\t\t}\n\n\t\tif ( ! handlers || ! handlers.length ) {\n\t\t\treturn returnFirstArg ? args[ 0 ] : undefined;\n\t\t}\n\n\t\tconst hookInfo = {\n\t\t\tname: hookName,\n\t\t\tcurrentIndex: 0,\n\t\t};\n\n\t\tasync function asyncRunner() {\n\t\t\ttry {\n\t\t\t\thooksStore.__current.add( hookInfo );\n\t\t\t\tlet result = returnFirstArg ? args[ 0 ] : undefined;\n\t\t\t\twhile ( hookInfo.currentIndex < handlers.length ) {\n\t\t\t\t\tconst handler = handlers[ hookInfo.currentIndex ];\n\t\t\t\t\tresult = await handler.callback.apply( null, args );\n\t\t\t\t\tif ( returnFirstArg ) {\n\t\t\t\t\t\targs[ 0 ] = result;\n\t\t\t\t\t}\n\t\t\t\t\thookInfo.currentIndex++;\n\t\t\t\t}\n\t\t\t\treturn returnFirstArg ? result : undefined;\n\t\t\t} finally {\n\t\t\t\thooksStore.__current.delete( hookInfo );\n\t\t\t}\n\t\t}\n\n\t\tfunction syncRunner() {\n\t\t\ttry {\n\t\t\t\thooksStore.__current.add( hookInfo );\n\t\t\t\tlet result = returnFirstArg ? args[ 0 ] : undefined;\n\t\t\t\twhile ( hookInfo.currentIndex < handlers.length ) {\n\t\t\t\t\tconst handler = handlers[ hookInfo.currentIndex ];\n\t\t\t\t\tresult = handler.callback.apply( null, args );\n\t\t\t\t\tif ( returnFirstArg ) {\n\t\t\t\t\t\targs[ 0 ] = result;\n\t\t\t\t\t}\n\t\t\t\t\thookInfo.currentIndex++;\n\t\t\t\t}\n\t\t\t\treturn returnFirstArg ? result : undefined;\n\t\t\t} finally {\n\t\t\t\thooksStore.__current.delete( hookInfo );\n\t\t\t}\n\t\t}\n\n\t\treturn ( async ? asyncRunner : syncRunner )();\n\t};\n}\n\nexport default createRunHook;\n", "/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n\n/**\n * Returns a function which, when invoked, will return the name of the\n * currently running hook, or `null` if no hook of the given type is currently\n * running.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return Function that returns the current hook name or null.\n */\nfunction createCurrentHook(\n\thooks: Hooks,\n\tstoreKey: StoreKey\n): () => string | null {\n\treturn function currentHook() {\n\t\tconst hooksStore = hooks[ storeKey ];\n\t\tconst currentArray = Array.from( hooksStore.__current );\n\t\treturn currentArray.at( -1 )?.name ?? null;\n\t};\n}\n\nexport default createCurrentHook;\n", "/**\n * Internal dependencies\n */\nimport type { Hooks, StoreKey } from './types';\n\n/**\n * Returns whether a hook is currently being executed.\n *\n */\nexport type DoingHook = (\n\t/**\n\t * The name of the hook to check for.\n\t * If omitted, will check for any hook being executed.\n\t */ hookName?: string\n) => boolean;\n\n/**\n * Returns a function which, when invoked, will return whether a hook is\n * currently being executed.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return Function that returns whether a hook is currently\n *                     being executed.\n */\nfunction createDoingHook( hooks: Hooks, storeKey: StoreKey ): DoingHook {\n\treturn function doingHook( hookName ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\t// If the hookName was not passed, check for any current hook.\n\t\tif ( 'undefined' === typeof hookName ) {\n\t\t\treturn hooksStore.__current.size > 0;\n\t\t}\n\n\t\t// Find if the `hookName` hook is in `__current`.\n\t\treturn Array.from( hooksStore.__current ).some(\n\t\t\t( hook ) => hook.name === hookName\n\t\t);\n\t};\n}\n\nexport default createDoingHook;\n", "/**\n * Internal dependencies\n */\nimport validateHookName from './validateHookName';\nimport type { Hooks, StoreKey } from './types';\n\n/**\n *\n * Returns the number of times an action has been fired.\n *\n */\nexport type DidHook = (\n\t/**\n\t * The hook name to check.\n\t */\n\thookName: string\n) => number | undefined;\n\n/**\n * Returns a function which, when invoked, will return the number of times a\n * hook has been called.\n *\n * @param hooks    Hooks instance.\n * @param storeKey\n *\n * @return  Function that returns a hook's call count.\n */\nfunction createDidHook( hooks: Hooks, storeKey: StoreKey ): DidHook {\n\treturn function didHook( hookName ) {\n\t\tconst hooksStore = hooks[ storeKey ];\n\n\t\tif ( ! validateHookName( hookName ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn hooksStore[ hookName ] && hooksStore[ hookName ].runs\n\t\t\t? hooksStore[ hookName ].runs\n\t\t\t: 0;\n\t};\n}\n\nexport default createDidHook;\n", "/**\n * Internal dependencies\n */\nimport createAddHook from './createAddHook';\nimport createRemoveHook from './createRemoveHook';\nimport createHasHook from './createHasHook';\nimport createRunHook from './createRunHook';\nimport createCurrentHook from './createCurrentHook';\nimport createDoingHook from './createDoingHook';\nimport createDidHook from './createDidHook';\nimport type { Store } from './types';\n\n/**\n * Internal class for constructing hooks. Use `createHooks()` function\n *\n * Note, it is necessary to expose this class to make its type public.\n *\n * @private\n */\nexport class _Hooks {\n\tpublic actions: Store;\n\tpublic filters: Store;\n\n\tpublic addAction: ReturnType< typeof createAddHook >;\n\tpublic addFilter: ReturnType< typeof createAddHook >;\n\tpublic removeAction: ReturnType< typeof createRemoveHook >;\n\tpublic removeFilter: ReturnType< typeof createRemoveHook >;\n\tpublic hasAction: ReturnType< typeof createHasHook >;\n\tpublic hasFilter: ReturnType< typeof createHasHook >;\n\tpublic removeAllActions: ReturnType< typeof createRemoveHook >;\n\tpublic removeAllFilters: ReturnType< typeof createRemoveHook >;\n\tpublic doAction: ReturnType< typeof createRunHook >;\n\tpublic doActionAsync: ReturnType< typeof createRunHook >;\n\tpublic applyFilters: ReturnType< typeof createRunHook >;\n\tpublic applyFiltersAsync: ReturnType< typeof createRunHook >;\n\tpublic currentAction: ReturnType< typeof createCurrentHook >;\n\tpublic currentFilter: ReturnType< typeof createCurrentHook >;\n\tpublic doingAction: ReturnType< typeof createDoingHook >;\n\tpublic doingFilter: ReturnType< typeof createDoingHook >;\n\tpublic didAction: ReturnType< typeof createDidHook >;\n\tpublic didFilter: ReturnType< typeof createDidHook >;\n\n\tconstructor() {\n\t\tthis.actions = Object.create( null );\n\t\tthis.actions.__current = new Set();\n\n\t\tthis.filters = Object.create( null );\n\t\tthis.filters.__current = new Set();\n\n\t\tthis.addAction = createAddHook( this, 'actions' );\n\t\tthis.addFilter = createAddHook( this, 'filters' );\n\t\tthis.removeAction = createRemoveHook( this, 'actions' );\n\t\tthis.removeFilter = createRemoveHook( this, 'filters' );\n\t\tthis.hasAction = createHasHook( this, 'actions' );\n\t\tthis.hasFilter = createHasHook( this, 'filters' );\n\t\tthis.removeAllActions = createRemoveHook( this, 'actions', true );\n\t\tthis.removeAllFilters = createRemoveHook( this, 'filters', true );\n\t\tthis.doAction = createRunHook( this, 'actions', false, false );\n\t\tthis.doActionAsync = createRunHook( this, 'actions', false, true );\n\t\tthis.applyFilters = createRunHook( this, 'filters', true, false );\n\t\tthis.applyFiltersAsync = createRunHook( this, 'filters', true, true );\n\t\tthis.currentAction = createCurrentHook( this, 'actions' );\n\t\tthis.currentFilter = createCurrentHook( this, 'filters' );\n\t\tthis.doingAction = createDoingHook( this, 'actions' );\n\t\tthis.doingFilter = createDoingHook( this, 'filters' );\n\t\tthis.didAction = createDidHook( this, 'actions' );\n\t\tthis.didFilter = createDidHook( this, 'filters' );\n\t}\n}\n\nexport type Hooks = _Hooks;\n\n/**\n * Returns an instance of the hooks object.\n *\n * @return A Hooks instance.\n */\nfunction createHooks(): Hooks {\n\treturn new _Hooks();\n}\n\nexport default createHooks;\n", "/**\n * Internal dependencies\n */\nimport createHooks from './createHooks';\n\nexport * from './types';\n\nexport const defaultHooks = createHooks();\n\nconst {\n\taddAction,\n\taddFilter,\n\tremoveAction,\n\tremoveFilter,\n\thasAction,\n\thasFilter,\n\tremoveAllActions,\n\tremoveAllFilters,\n\tdoAction,\n\tdoActionAsync,\n\tapplyFilters,\n\tapplyFiltersAsync,\n\tcurrentAction,\n\tcurrentFilter,\n\tdoingAction,\n\tdoingFilter,\n\tdidAction,\n\tdidFilter,\n\tactions,\n\tfilters,\n} = defaultHooks;\n\nexport {\n\tcreateHooks,\n\taddAction,\n\taddFilter,\n\tremoveAction,\n\tremoveFilter,\n\thasAction,\n\thasFilter,\n\tremoveAllActions,\n\tremoveAllFilters,\n\tdoAction,\n\tdoActionAsync,\n\tapplyFilters,\n\tapplyFiltersAsync,\n\tcurrentAction,\n\tcurrentFilter,\n\tdoingAction,\n\tdoingFilter,\n\tdidAction,\n\tdidFilter,\n\tactions,\n\tfilters,\n};\n", "/**\n * Regular expression matching format placeholder syntax.\n *\n * The pattern for matching named arguments is a naive and incomplete matcher\n * against valid JavaScript identifier names.\n *\n * via Mathias Bynens:\n *\n * >An identifier must start with $, _, or any character in the Unicode\n * >categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase\n * >letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter\n * >number (Nl)”.\n * >\n * >The rest of the string can contain the same characters, plus any U+200C zero\n * >width non-joiner characters, U+200D zero width joiner characters, and\n * >characters in the Unicode categories “Non-spacing mark (Mn)”, “Spacing\n * >combining mark (Mc)”, “Decimal digit number (Nd)”, or “Connector\n * >punctuation (Pc)”.\n *\n * If browser support is constrained to those supporting ES2015, this could be\n * made more accurate using the `u` flag:\n *\n * ```\n * /^[$_\\p{L}\\p{Nl}][$_\\p{L}\\p{Nl}\\u200C\\u200D\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/u;\n * ```\n *\n * @see http://www.pixelbeat.org/programming/gcc/format_specs.html\n * @see https://mathiasbynens.be/notes/javascript-identifiers#valid-identifier-names\n *\n * @type {RegExp}\n */\nvar PATTERN =\n\t/%(((\\d+)\\$)|(\\(([$_a-zA-Z][$_a-zA-Z0-9]*)\\)))?[ +0#-]*\\d*(\\.(\\d+|\\*))?(ll|[lhqL])?([cduxXefgsp%])/g;\n//               ▲         ▲                    ▲       ▲  ▲            ▲           ▲ type\n//               │         │                    │       │  │            └ Length (unsupported)\n//               │         │                    │       │  └ Precision / max width\n//               │         │                    │       └ Min width (unsupported)\n//               │         │                    └ Flags (unsupported)\n//               └ Index   └ Name (for named arguments)\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // ⇒ 'Hello world!'\n * ```\n * @template {string} T\n * @overload\n * @param {T} string - string printf format string\n * @param {...import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\n\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // ⇒ 'Hello world!'\n * ```\n * @template {string} T\n * @overload\n * @param {T} string - string printf format string\n * @param {import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\n\n/**\n * Given a format string, returns string with arguments interpolatation.\n * Arguments can either be provided directly via function arguments spread, or\n * with an array as the second argument.\n *\n * @see https://en.wikipedia.org/wiki/Printf_format_string\n *\n * @example\n *\n * ```js\n * import sprintf from '@tannin/sprintf';\n *\n * sprintf( 'Hello %s!', 'world' );\n * // ⇒ 'Hello world!'\n * ```\n * @template {string} T\n * @param {T} string - string printf format string\n * @param {...import('../types').SprintfArgs<T>} args - arguments to interpolate\n *\n * @return {string} Formatted string.\n */\nexport default function sprintf(string, ...args) {\n\tvar i = 0;\n\tif (Array.isArray(args[0])) {\n\t\targs = /** @type {import('../types').SprintfArgs<T>[]} */ (\n\t\t\t/** @type {unknown} */ args[0]\n\t\t);\n\t}\n\n\treturn string.replace(PATTERN, function () {\n\t\tvar index,\n\t\t\t// name needs to be documented as `string | undefined` else value will have tpye unknown.\n\t\t\t/**\n\t\t\t * Name of the argument to substitute, if any.\n\t\t\t *\n\t\t\t * @type {string | undefined}\n\t\t\t */\n\t\t\tname,\n\t\t\tprecision,\n\t\t\ttype,\n\t\t\tvalue;\n\n\t\tindex = arguments[3];\n\t\tname = arguments[5];\n\t\tprecision = arguments[7];\n\t\ttype = arguments[9];\n\n\t\t// There's no placeholder substitution in the explicit \"%\", meaning it\n\t\t// is not necessary to increment argument index.\n\t\tif (type === '%') {\n\t\t\treturn '%';\n\t\t}\n\n\t\t// Asterisk precision determined by peeking / shifting next argument.\n\t\tif (precision === '*') {\n\t\t\tprecision = args[i];\n\t\t\ti++;\n\t\t}\n\n\t\tif (name === undefined) {\n\t\t\t// If not a positional argument, use counter value.\n\t\t\tif (index === undefined) {\n\t\t\t\tindex = i + 1;\n\t\t\t}\n\n\t\t\ti++;\n\n\t\t\t// Positional argument.\n\t\t\tvalue = args[index - 1];\n\t\t} else if (\n\t\t\targs[0] &&\n\t\t\ttypeof args[0] === 'object' &&\n\t\t\targs[0].hasOwnProperty(name)\n\t\t) {\n\t\t\t// If it's a named argument, use name.\n\t\t\tvalue = args[0][name];\n\t\t}\n\n\t\t// Parse as type.\n\t\tif (type === 'f') {\n\t\t\tvalue = parseFloat(value) || 0;\n\t\t} else if (type === 'd') {\n\t\t\tvalue = parseInt(value) || 0;\n\t\t}\n\n\t\t// Apply precision.\n\t\tif (precision !== undefined) {\n\t\t\tif (type === 'f') {\n\t\t\t\tvalue = value.toFixed(precision);\n\t\t\t} else if (type === 's') {\n\t\t\t\tvalue = value.substr(0, precision);\n\t\t\t}\n\t\t}\n\n\t\t// To avoid \"undefined\" concatenation, return empty string if no\n\t\t// placeholder substitution can be performed.\n\t\treturn value !== undefined && value !== null ? value : '';\n\t});\n}\n"],
  "mappings": "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",
  "names": ["validateNamespace", "namespace", "console", "error", "test", "validateHookName", "hookName", "console", "error", "test", "createAddHook", "hooks", "storeKey", "addHook", "hookName", "namespace", "callback", "priority", "hooksStore", "validateHookName", "validateNamespace", "console", "error", "handler", "handlers", "i", "length", "splice", "__current", "forEach", "hookInfo", "name", "currentIndex", "runs", "doAction", "createRemoveHook", "hooks", "storeKey", "removeAll", "removeHook", "hookName", "namespace", "hooksStore", "validateHookName", "validateNamespace", "handlersRemoved", "handlers", "length", "runs", "i", "splice", "__current", "forEach", "hookInfo", "name", "currentIndex", "doAction", "createHasHook", "hooks", "storeKey", "hasHook", "hookName", "namespace", "hooksStore", "handlers", "some", "hook", "createRunHook", "hooks", "storeKey", "returnFirstArg", "async", "runHook", "hookName", "args", "hooksStore", "handlers", "runs", "all", "push", "length", "undefined", "hookInfo", "name", "currentIndex", "asyncRunner", "__current", "add", "result", "handler", "callback", "apply", "delete", "syncRunner", "createCurrentHook", "hooks", "storeKey", "currentHook", "_currentArray$at$name", "hooksStore", "currentArray", "Array", "from", "__current", "at", "name", "createDoingHook", "hooks", "storeKey", "doingHook", "hookName", "hooksStore", "__current", "size", "Array", "from", "some", "hook", "name", "createDidHook", "hooks", "storeKey", "didHook", "hookName", "hooksStore", "validateHookName", "runs", "_Hooks", "constructor", "actions", "Object", "create", "__current", "Set", "filters", "addAction", "createAddHook", "addFilter", "removeAction", "createRemoveHook", "removeFilter", "hasAction", "createHasHook", "hasFilter", "removeAllActions", "removeAllFilters", "doAction", "createRunHook", "doActionAsync", "applyFilters", "applyFiltersAsync", "currentAction", "createCurrentHook", "currentFilter", "doingAction", "createDoingHook", "doingFilter", "didAction", "createDidHook", "didFilter", "createHooks", "defaultHooks", "createHooks", "addAction", "addFilter", "removeAction", "removeFilter", "hasAction", "hasFilter", "removeAllActions", "removeAllFilters", "doAction", "doActionAsync", "applyFilters", "applyFiltersAsync", "currentAction", "currentFilter", "doingAction", "doingFilter", "didAction", "didFilter", "actions", "filters"]
}
