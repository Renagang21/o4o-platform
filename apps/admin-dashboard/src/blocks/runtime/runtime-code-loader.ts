/**
 * Runtime Code Loader
 * Phase 2-A: Compile AI-generated TSX code into React components
 *
 * This module safely compiles AI-generated component code at runtime
 * using Function constructor (safer than eval).
 */

import React from 'react';
import { AlertCircle } from 'lucide-react';

/**
 * Compile result
 */
export interface CompileResult {
  success: boolean;
  component?: React.ComponentType<any>;
  error?: string;
  componentName?: string;
}

/**
 * Available dependencies for runtime components
 * These are injected into the component scope
 */
const RUNTIME_DEPENDENCIES = {
  React,
  // Add more dependencies as needed
  // Example: Button, Card, etc. from shadcn/ui
};

/**
 * Extract component name from code
 */
function extractComponentName(code: string): string | null {
  // Try to find: export const ComponentName
  const exportConstMatch = code.match(/export\s+const\s+(\w+)/);
  if (exportConstMatch) {
    return exportConstMatch[1];
  }

  // Try to find: export function ComponentName
  const exportFunctionMatch = code.match(/export\s+function\s+(\w+)/);
  if (exportFunctionMatch) {
    return exportFunctionMatch[1];
  }

  // Try to find: const ComponentName =
  const constMatch = code.match(/const\s+(\w+)\s*[:=]/);
  if (constMatch) {
    return constMatch[1];
  }

  return null;
}

/**
 * Clean and prepare code for compilation
 */
function prepareCode(code: string): string {
  // Remove import statements (we'll inject dependencies instead)
  let cleaned = code.replace(/import\s+.*?from\s+['"].*?['"];?\n?/g, '');

  // Remove export statements but keep the declarations
  cleaned = cleaned.replace(/export\s+(const|function|default)\s+/g, '$1 ');

  return cleaned.trim();
}

/**
 * Compile AI-generated component code into a React component
 *
 * @param componentCode - The TSX/JSX code generated by AI
 * @returns CompileResult with component or error
 */
export function compileComponent(componentCode: string): CompileResult {
  try {
    // Extract component name
    const componentName = extractComponentName(componentCode);
    if (!componentName) {
      throw new Error('Could not extract component name from code');
    }

    // Prepare code (remove imports, clean exports)
    const preparedCode = prepareCode(componentCode);

    // Build the function string
    // We create a function that returns the component
    const functionBody = `
      ${preparedCode}
      return ${componentName};
    `;

    // Create the function with injected dependencies
    // Dependencies are passed as parameters to avoid global scope pollution
    const dependencyNames = Object.keys(RUNTIME_DEPENDENCIES);
    const dependencyValues = Object.values(RUNTIME_DEPENDENCIES);

    // Create the function
    // eslint-disable-next-line no-new-func
    const componentFactory = new Function(
      ...dependencyNames,
      functionBody
    );

    // Execute the function with dependencies to get the component
    const Component = componentFactory(...dependencyValues);

    // Validate that we got a valid component
    if (typeof Component !== 'function') {
      throw new Error('Compiled code did not return a valid React component');
    }

    return {
      success: true,
      component: Component,
      componentName,
    };
  } catch (error: any) {
    console.error('‚ùå Component compilation failed:', error);

    return {
      success: false,
      error: error.message || 'Unknown compilation error',
    };
  }
}

/**
 * Create a fallback component for failed compilations
 */
export function createFallbackComponent(
  componentName: string,
  errorMessage: string
): React.ComponentType<any> {
  return (props: any) => {
    return React.createElement(
      'div',
      {
        className: 'border-2 border-red-300 bg-red-50 rounded-lg p-4',
      },
      [
        React.createElement(
          'div',
          { className: 'flex items-center gap-2 mb-2', key: 'header' },
          [
            React.createElement(AlertCircle, {
              className: 'w-5 h-5 text-red-600',
              key: 'icon',
            }),
            React.createElement(
              'h4',
              { className: 'font-semibold text-red-900', key: 'title' },
              `${componentName} (Compilation Failed)`
            ),
          ]
        ),
        React.createElement(
          'div',
          { className: 'text-sm text-red-700 mb-2', key: 'error' },
          `Error: ${errorMessage}`
        ),
        React.createElement(
          'pre',
          { className: 'text-xs bg-white p-2 rounded border border-red-200 overflow-auto', key: 'props' },
          JSON.stringify(props, null, 2)
        ),
      ]
    );
  };
}

/**
 * Validate generated component code
 * Basic checks before compilation
 */
export function validateComponentCode(code: string): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // Check if code is not empty
  if (!code || code.trim().length === 0) {
    errors.push('Component code is empty');
  }

  // Check for component declaration
  const hasComponent =
    /export\s+(const|function)\s+\w+/.test(code) ||
    /(const|function)\s+\w+/.test(code);

  if (!hasComponent) {
    errors.push('No component declaration found');
  }

  // Check for suspicious patterns (basic security check)
  const suspiciousPatterns = [
    /eval\s*\(/,
    /Function\s*\(/,
    /XMLHttpRequest/,
    /fetch\s*\(/,
    /localStorage/,
    /sessionStorage/,
    /document\.cookie/,
  ];

  suspiciousPatterns.forEach(pattern => {
    if (pattern.test(code)) {
      errors.push(`Suspicious code pattern detected: ${pattern.source}`);
    }
  });

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Test compile a component (dry run)
 * Useful for validation before actual registration
 */
export function testCompile(componentCode: string): CompileResult {
  // First validate
  const validation = validateComponentCode(componentCode);
  if (!validation.valid) {
    return {
      success: false,
      error: `Validation failed: ${validation.errors.join(', ')}`,
    };
  }

  // Try to compile
  return compileComponent(componentCode);
}
