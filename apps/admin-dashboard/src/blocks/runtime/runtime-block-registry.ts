/**
 * Runtime Block Registry
 * Phase 2-A: Dynamic block registration at runtime
 *
 * This registry manages blocks that are generated by AI and registered
 * at runtime without file system modifications.
 */

import { BlockDefinition } from '../registry/types';

interface RuntimeBlockEntry {
  definition: BlockDefinition;
  componentFunction: any;
  generatedAt: string;
  spec?: {
    componentName: string;
    reason: string;
    props?: string[];
    style?: string;
    category?: string;
  };
}

/**
 * Runtime Block Registry
 * Manages dynamically generated blocks in memory and localStorage
 */
class RuntimeBlockRegistry {
  private blocks: Map<string, RuntimeBlockEntry> = new Map();
  private storageKey = 'o4o-runtime-blocks';

  constructor() {
    this.loadFromStorage();
  }

  /**
   * Register a runtime block
   */
  registerRuntimeBlock(
    definition: BlockDefinition,
    componentFunction: any,
    spec?: RuntimeBlockEntry['spec']
  ): void {
    const entry: RuntimeBlockEntry = {
      definition,
      componentFunction,
      generatedAt: new Date().toISOString(),
      spec,
    };

    this.blocks.set(definition.name, entry);
    this.saveToStorage();

    console.log(`‚úÖ Runtime block registered: ${definition.name}`);
  }

  /**
   * Get all runtime blocks
   */
  getRuntimeBlocks(): RuntimeBlockEntry[] {
    return Array.from(this.blocks.values());
  }

  /**
   * Find a runtime block by name
   */
  findByName(blockName: string): RuntimeBlockEntry | undefined {
    return this.blocks.get(blockName);
  }

  /**
   * Get all runtime block definitions (for merging with static registry)
   */
  getRuntimeDefinitions(): BlockDefinition[] {
    return this.getRuntimeBlocks().map(entry => entry.definition);
  }

  /**
   * Check if a block name is registered at runtime
   */
  hasBlock(blockName: string): boolean {
    return this.blocks.has(blockName);
  }

  /**
   * Remove a runtime block
   */
  removeBlock(blockName: string): boolean {
    const deleted = this.blocks.delete(blockName);
    if (deleted) {
      this.saveToStorage();
      console.log(`üóëÔ∏è Runtime block removed: ${blockName}`);
    }
    return deleted;
  }

  /**
   * Clear all runtime blocks
   */
  clearAll(): void {
    this.blocks.clear();
    this.saveToStorage();
    console.log('üóëÔ∏è All runtime blocks cleared');
  }

  /**
   * Save runtime blocks to localStorage
   * Note: We only save the definition and code, not the compiled function
   */
  private saveToStorage(): void {
    try {
      const data: Record<string, {
        definition: BlockDefinition;
        componentCode?: string;
        generatedAt: string;
        spec?: RuntimeBlockEntry['spec'];
      }> = {};

      this.blocks.forEach((entry, name) => {
        // Store definition and metadata, but not the function itself
        data[name] = {
          definition: entry.definition,
          generatedAt: entry.generatedAt,
          spec: entry.spec,
        };
      });

      localStorage.setItem(this.storageKey, JSON.stringify(data));
    } catch (error) {
      console.error('Failed to save runtime blocks to localStorage:', error);
    }
  }

  /**
   * Load runtime blocks from localStorage
   * Note: This only loads metadata. Actual components need to be re-compiled.
   */
  private loadFromStorage(): void {
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (!stored) return;

      const data = JSON.parse(stored);

      // We load the metadata, but components will need to be re-generated
      // This is just to track what blocks were previously generated
      Object.entries(data).forEach(([name, entry]: [string, any]) => {
        console.log(`üì¶ Found stored runtime block metadata: ${name}`);
        // Note: We don't register the block here because we don't have the component function
        // This is just for reference. Actual re-generation should be triggered by the UI.
      });

      console.log(`üì¶ Loaded ${Object.keys(data).length} runtime block metadata from storage`);
    } catch (error) {
      console.error('Failed to load runtime blocks from localStorage:', error);
    }
  }

  /**
   * Get storage metadata (for debugging)
   */
  getStorageMetadata(): any {
    try {
      const stored = localStorage.getItem(this.storageKey);
      return stored ? JSON.parse(stored) : null;
    } catch {
      return null;
    }
  }

  /**
   * Export runtime blocks as JSON (for backup/debugging)
   */
  exportBlocks(): string {
    const data = {
      exported: new Date().toISOString(),
      blocks: this.getRuntimeBlocks().map(entry => ({
        name: entry.definition.name,
        title: entry.definition.title,
        category: entry.definition.category,
        generatedAt: entry.generatedAt,
        spec: entry.spec,
      })),
    };

    return JSON.stringify(data, null, 2);
  }
}

// Singleton instance
export const runtimeBlockRegistry = new RuntimeBlockRegistry();

/**
 * Merge runtime blocks with static block registry
 * This is used when rendering blocks in the editor
 */
export function mergeWithStaticRegistry(staticBlocks: BlockDefinition[]): BlockDefinition[] {
  const runtimeDefinitions = runtimeBlockRegistry.getRuntimeDefinitions();

  // Create a map for quick lookup
  const blockMap = new Map<string, BlockDefinition>();

  // Add static blocks first
  staticBlocks.forEach(block => {
    blockMap.set(block.name, block);
  });

  // Override with runtime blocks (runtime takes precedence)
  runtimeDefinitions.forEach(block => {
    blockMap.set(block.name, block);
  });

  return Array.from(blockMap.values());
}
