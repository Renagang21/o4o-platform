name: Deploy API Server (Production)

# API ì„œë²„ ì ì§„ì  ë°°í¬ ì›Œí¬í”Œë¡œìš°
# íŠ¸ë¦¬ê±°: apps/api-server ê²½ë¡œ ë³€ê²½ ì‹œ
# ë‹¨ê³„: Build â†’ Test â†’ Deploy â†’ Health Check

on:
  push:
    branches: [main]
    paths:
      - 'apps/api-server/**'
      - '.github/workflows/deploy-api-server.yml'
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy without path changes'
        required: false
        default: 'false'

concurrency:
  group: deploy-api-server-${{ github.ref }}
  cancel-in-progress: false

env:
  SERVICE_NAME: api-server
  SERVICE_PORT: 4000
  PM2_APP_NAME: o4o-api-server
  DEPLOY_PATH: /home/ubuntu/o4o-platform
  NODE_VERSION: '20.18.0'

jobs:
  # ë‹¨ê³„ 1: ë¹Œë“œ ë° í…ŒìŠ¤íŠ¸
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
    
    - name: Validate environment
      run: bash scripts/validate-deploy-env.sh
      
    - name: Install dependencies
      run: |
        npm ci
        bash scripts/setup-ci-env.sh
    
    - name: Build shared packages
      run: |
        echo "Building shared packages first..."
        bash scripts/build-packages.sh
        
    - name: Install API server dependencies
      run: |
        cd apps/api-server
        npm ci
        
    - name: TypeScript type check
      run: |
        npm run type-check --workspace=@o4o/api-server
        
    - name: Run tests
      run: |
        npm run test --workspace=@o4o/api-server
        
    - name: Build application
      run: |
        npm run build --workspace=@o4o/api-server
        
    - name: Validate build output
      run: |
        cd apps/api-server
        test -f dist/main.js || (echo "Error: dist/main.js not found" && exit 1)
        test -d dist || (echo "Error: dist directory not found" && exit 1)
        echo "Build validation successful"
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: api-server-build
        path: |
          apps/api-server/dist/
          apps/api-server/package.json
          apps/api-server/package-lock.json
        retention-days: 1

  # ë‹¨ê³„ 2: ìš´ì˜ ì„œë²„ ë°°í¬
  deploy:
    needs: build-and-test
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: api-server-build
        path: apps/api-server/
        
    - name: Setup SSH key
      run: |
        # Debug SSH key format
        echo "ğŸ” Setting up SSH key..."
        
        # Create SSH directory
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Save the SSH key with proper formatting
        echo "${{ secrets.API_SSH_KEY }}" > ~/.ssh/id_rsa.tmp
        
        # Fix common SSH key issues
        # 1. Remove Windows line endings
        # 2. Ensure proper line breaks
        # 3. Remove any extra whitespace
        cat ~/.ssh/id_rsa.tmp | sed 's/\r$//' | sed 's/\\n/\n/g' > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        rm ~/.ssh/id_rsa.tmp
        
        # Debug key info
        echo "SSH key file info:"
        ls -la ~/.ssh/id_rsa
        echo "First line: $(head -n 1 ~/.ssh/id_rsa)"
        echo "Last line: $(tail -n 1 ~/.ssh/id_rsa)"
        echo "Total lines: $(wc -l < ~/.ssh/id_rsa)"
        
        # Check key format and convert if needed
        KEY_FORMAT="unknown"
        if grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/id_rsa; then
          KEY_FORMAT="rsa"
          echo "âœ… Key is in RSA format"
        elif grep -q "BEGIN PRIVATE KEY" ~/.ssh/id_rsa; then
          KEY_FORMAT="pkcs8"
          echo "âš ï¸  Key is in PKCS#8 format, converting to RSA..."
          # Convert PKCS#8 to RSA format
          openssl rsa -in ~/.ssh/id_rsa -out ~/.ssh/id_rsa.converted 2>/dev/null || true
          if [ -f ~/.ssh/id_rsa.converted ]; then
            mv ~/.ssh/id_rsa.converted ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            echo "âœ… Successfully converted to RSA format"
          fi
        elif grep -q "BEGIN OPENSSH PRIVATE KEY" ~/.ssh/id_rsa; then
          KEY_FORMAT="openssh"
          echo "âš ï¸  Key is in OpenSSH format, converting to RSA..."
          # Convert OpenSSH to RSA format
          ssh-keygen -p -m PEM -f ~/.ssh/id_rsa -N "" 2>/dev/null || true
          echo "âœ… Attempted conversion to RSA format"
        fi
        
        # Validate the key
        echo "Validating SSH key..."
        if ssh-keygen -l -f ~/.ssh/id_rsa >/dev/null 2>&1; then
          echo "âœ… SSH key validation successful"
          ssh-keygen -l -f ~/.ssh/id_rsa
        else
          echo "âŒ SSH key validation failed"
          echo "Error details:"
          ssh-keygen -l -f ~/.ssh/id_rsa 2>&1 || true
          
          # Try to use the key anyway with ssh-add
          eval "$(ssh-agent -s)"
          if ssh-add ~/.ssh/id_rsa 2>/dev/null; then
            echo "âœ… Key added to ssh-agent successfully"
          else
            echo "âŒ Failed to add key to ssh-agent"
            echo "Please ensure your SSH key:"
            echo "1. Is in PEM format (begins with -----BEGIN RSA PRIVATE KEY-----)"
            echo "2. Has no passphrase"
            echo "3. Uses Unix line endings (LF)"
            echo "4. Is the complete key including header and footer"
            exit 1
          fi
        fi
        
        # Setup SSH config for better compatibility
        cat > ~/.ssh/config << 'EOF'
        Host *
          StrictHostKeyChecking no
          UserKnownHostsFile=/dev/null
          IdentityFile ~/.ssh/id_rsa
          IdentitiesOnly yes
          PubkeyAcceptedKeyTypes +ssh-rsa
          HostKeyAlgorithms +ssh-rsa
        EOF
        chmod 600 ~/.ssh/config
        
        # Add host to known hosts
        ssh-keyscan -H ${{ secrets.API_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
        
        echo "âœ… SSH setup completed"
        
    - name: Create deployment directory
      run: |
        ssh ${{ secrets.API_USER }}@${{ secrets.API_HOST }} "
          mkdir -p ${{ env.DEPLOY_PATH }}/apps/api-server
        "
        
    - name: Create environment file
      run: |
        ssh ${{ secrets.API_USER }}@${{ secrets.API_HOST }} "
          cat > ${{ env.DEPLOY_PATH }}/apps/api-server/.env.production << 'EOF'
          NODE_ENV=production
          PORT=${{ env.SERVICE_PORT }}
          
          # Database Configuration
          DB_HOST=${{ secrets.DB_HOST }}
          DB_PORT=${{ secrets.DB_PORT }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          DB_NAME=${{ secrets.DB_NAME }}
          
          # JWT Configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
          
          # CORS Configuration
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          
          # Logging Configuration
          LOG_LEVEL=${{ secrets.LOG_LEVEL }}
          
          # Health Check
          HEALTH_CHECK_KEY=${{ secrets.HEALTH_CHECK_KEY }}
          EOF
        "
        
    - name: Deploy application files
      run: |
        rsync -avz --delete \
          -e "ssh" \
          apps/api-server/ \
          ${{ secrets.API_USER }}@${{ secrets.API_HOST }}:${{ env.DEPLOY_PATH }}/apps/api-server/
          
    - name: Install production dependencies
      run: |
        ssh ${{ secrets.API_USER }}@${{ secrets.API_HOST }} "
          cd ${{ env.DEPLOY_PATH }}/apps/api-server
          npm install --only=production
        "
        
    - name: Run database migrations
      run: |
        ssh ${{ secrets.API_USER }}@${{ secrets.API_HOST }} "
          cd ${{ env.DEPLOY_PATH }}/apps/api-server
          npm run migration:run
        "
        
    - name: Setup PM2 ecosystem file
      run: |
        ssh ${{ secrets.API_USER }}@${{ secrets.API_HOST }} "
          cat > ${{ env.DEPLOY_PATH }}/ecosystem.config.js << 'EOF'
          module.exports = {
            apps: [{
              name: '${{ env.PM2_APP_NAME }}',
              script: './dist/main.js',
              cwd: '${{ env.DEPLOY_PATH }}/apps/api-server',
              instances: 'max',
              exec_mode: 'cluster',
              env_file: '.env.production',
              max_memory_restart: '1G',
              node_args: '--max-old-space-size=1024',
              error_file: '${{ env.DEPLOY_PATH }}/logs/api-server-error.log',
              out_file: '${{ env.DEPLOY_PATH }}/logs/api-server-out.log',
              log_file: '${{ env.DEPLOY_PATH }}/logs/api-server-combined.log',
              time: true,
              autorestart: true,
              max_restarts: 10,
              min_uptime: '10s',
              kill_timeout: 30000,
              wait_ready: true,
              listen_timeout: 10000,
              health_check_grace_period: 30000
            }]
          };
          EOF
        "
        
    - name: Create logs directory
      run: |
        ssh ${{ secrets.API_USER }}@${{ secrets.API_HOST }} "
          mkdir -p ${{ env.DEPLOY_PATH }}/logs
        "
        
    - name: Deploy with PM2 (Zero-downtime)
      run: |
        ssh ${{ secrets.API_USER }}@${{ secrets.API_HOST }} "
          cd ${{ env.DEPLOY_PATH }}
          
          # PM2 í”„ë¡œì„¸ìŠ¤ ì¡´ì¬ ì—¬ë¶€ í™•ì¸
          if pm2 describe ${{ env.PM2_APP_NAME }} > /dev/null 2>&1; then
            echo 'Reloading existing PM2 process...'
            pm2 reload ecosystem.config.js --update-env
          else
            echo 'Starting new PM2 process...'
            pm2 start ecosystem.config.js
          fi
          
          # PM2 ìƒíƒœ ì €ì¥
          pm2 save
        "

  # ë‹¨ê³„ 3: ë°°í¬ í›„ í—¬ìŠ¤ì²´í¬
  health-check:
    needs: deploy
    runs-on: ubuntu-latest
    
    steps:
    - name: Wait for service startup
      run: sleep 30
      
    - name: Health check
      run: |
        # API ì„œë²„ í—¬ìŠ¤ì²´í¬
        for i in {1..10}; do
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "X-Health-Check-Key: ${{ secrets.HEALTH_CHECK_KEY }}" \
            https://api.neture.co.kr/health || echo "000")
            
          if [ "$response" = "200" ]; then
            echo "âœ… API ì„œë²„ í—¬ìŠ¤ì²´í¬ ì„±ê³µ (ì‘ë‹µ ì½”ë“œ: $response)"
            break
          else
            echo "â³ API ì„œë²„ í—¬ìŠ¤ì²´í¬ ëŒ€ê¸° ì¤‘... (ì‹œë„ $i/10, ì‘ë‹µ ì½”ë“œ: $response)"
            if [ $i -eq 10 ]; then
              echo "âŒ API ì„œë²„ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨"
              exit 1
            fi
            sleep 10
          fi
        done
        
    - name: Database connection check
      run: |
        response=$(curl -s -H "X-Health-Check-Key: ${{ secrets.HEALTH_CHECK_KEY }}" \
          https://api.neture.co.kr/health/database)
          
        if echo "$response" | grep -q "\"status\":\"healthy\""; then
          echo "âœ… ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í™•ì¸ ì„±ê³µ"
        else
          echo "âŒ ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í™•ì¸ ì‹¤íŒ¨"
          echo "Response: $response"
          exit 1
        fi
        
    - name: API endpoints smoke test
      run: |
        # ì£¼ìš” API ì—”ë“œí¬ì¸íŠ¸ smoke test
        endpoints=(
          "/health"
          "/api/auth/health"
          "/api/ecommerce/health"
        )
        
        for endpoint in "${endpoints[@]}"; do
          response=$(curl -s -o /dev/null -w "%{http_code}" \
            "https://api.neture.co.kr$endpoint")
            
          if [ "$response" = "200" ] || [ "$response" = "401" ]; then
            echo "âœ… $endpoint ì—”ë“œí¬ì¸íŠ¸ ì •ìƒ (ì‘ë‹µ ì½”ë“œ: $response)"
          else
            echo "âŒ $endpoint ì—”ë“œí¬ì¸íŠ¸ ì˜¤ë¥˜ (ì‘ë‹µ ì½”ë“œ: $response)"
            exit 1
          fi
        done

  # ë‹¨ê³„ 4: ë°°í¬ ì™„ë£Œ ì•Œë¦¼
  notify:
    needs: [deploy, health-check]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Deployment success notification
      if: needs.health-check.result == 'success'
      run: |
        echo "ğŸš€ API ì„œë²„ ë°°í¬ ì„±ê³µ!"
        echo "ğŸ“ ì„œë¹„ìŠ¤ URL: https://api.neture.co.kr"
        echo "ğŸ• ë°°í¬ ì‹œê°„: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "ğŸ“Š í—¬ìŠ¤ì²´í¬: í†µê³¼"
        
    - name: Deployment failure notification
      if: needs.health-check.result == 'failure' || needs.deploy.result == 'failure'
      run: |
        echo "âŒ API ì„œë²„ ë°°í¬ ì‹¤íŒ¨!"
        echo "ğŸ” ë¡œê·¸ë¥¼ í™•ì¸í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•˜ì„¸ìš”."
        exit 1

  # ë‹¨ê³„ 5: ë¡¤ë°± ì¤€ë¹„ (ì‹¤íŒ¨ ì‹œ)
  rollback:
    needs: [deploy, health-check]
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
    - name: Setup SSH key
      run: |
        # Debug SSH key format
        echo "ğŸ” Setting up SSH key..."
        
        # Create SSH directory
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        
        # Save the SSH key with proper formatting
        echo "${{ secrets.API_SSH_KEY }}" > ~/.ssh/id_rsa.tmp
        
        # Fix common SSH key issues
        # 1. Remove Windows line endings
        # 2. Ensure proper line breaks
        # 3. Remove any extra whitespace
        cat ~/.ssh/id_rsa.tmp | sed 's/\r$//' | sed 's/\\n/\n/g' > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        rm ~/.ssh/id_rsa.tmp
        
        # Debug key info
        echo "SSH key file info:"
        ls -la ~/.ssh/id_rsa
        echo "First line: $(head -n 1 ~/.ssh/id_rsa)"
        echo "Last line: $(tail -n 1 ~/.ssh/id_rsa)"
        echo "Total lines: $(wc -l < ~/.ssh/id_rsa)"
        
        # Check key format and convert if needed
        KEY_FORMAT="unknown"
        if grep -q "BEGIN RSA PRIVATE KEY" ~/.ssh/id_rsa; then
          KEY_FORMAT="rsa"
          echo "âœ… Key is in RSA format"
        elif grep -q "BEGIN PRIVATE KEY" ~/.ssh/id_rsa; then
          KEY_FORMAT="pkcs8"
          echo "âš ï¸  Key is in PKCS#8 format, converting to RSA..."
          # Convert PKCS#8 to RSA format
          openssl rsa -in ~/.ssh/id_rsa -out ~/.ssh/id_rsa.converted 2>/dev/null || true
          if [ -f ~/.ssh/id_rsa.converted ]; then
            mv ~/.ssh/id_rsa.converted ~/.ssh/id_rsa
            chmod 600 ~/.ssh/id_rsa
            echo "âœ… Successfully converted to RSA format"
          fi
        elif grep -q "BEGIN OPENSSH PRIVATE KEY" ~/.ssh/id_rsa; then
          KEY_FORMAT="openssh"
          echo "âš ï¸  Key is in OpenSSH format, converting to RSA..."
          # Convert OpenSSH to RSA format
          ssh-keygen -p -m PEM -f ~/.ssh/id_rsa -N "" 2>/dev/null || true
          echo "âœ… Attempted conversion to RSA format"
        fi
        
        # Validate the key
        echo "Validating SSH key..."
        if ssh-keygen -l -f ~/.ssh/id_rsa >/dev/null 2>&1; then
          echo "âœ… SSH key validation successful"
          ssh-keygen -l -f ~/.ssh/id_rsa
        else
          echo "âŒ SSH key validation failed"
          echo "Error details:"
          ssh-keygen -l -f ~/.ssh/id_rsa 2>&1 || true
          
          # Try to use the key anyway with ssh-add
          eval "$(ssh-agent -s)"
          if ssh-add ~/.ssh/id_rsa 2>/dev/null; then
            echo "âœ… Key added to ssh-agent successfully"
          else
            echo "âŒ Failed to add key to ssh-agent"
            echo "Please ensure your SSH key:"
            echo "1. Is in PEM format (begins with -----BEGIN RSA PRIVATE KEY-----)"
            echo "2. Has no passphrase"
            echo "3. Uses Unix line endings (LF)"
            echo "4. Is the complete key including header and footer"
            exit 1
          fi
        fi
        
        # Setup SSH config for better compatibility
        cat > ~/.ssh/config << 'EOF'
        Host *
          StrictHostKeyChecking no
          UserKnownHostsFile=/dev/null
          IdentityFile ~/.ssh/id_rsa
          IdentitiesOnly yes
          PubkeyAcceptedKeyTypes +ssh-rsa
          HostKeyAlgorithms +ssh-rsa
        EOF
        chmod 600 ~/.ssh/config
        
        # Add host to known hosts
        ssh-keyscan -H ${{ secrets.API_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
        
        echo "âœ… SSH setup completed"
        
    - name: Rollback to previous version
      run: |
        ssh ${{ secrets.API_USER }}@${{ secrets.API_HOST }} "
          cd ${{ env.DEPLOY_PATH }}
          
          # ì´ì „ ë°±ì—…ì—ì„œ ë³µì›
          if [ -d 'apps/api-server.backup' ]; then
            echo 'ì´ì „ ë²„ì „ìœ¼ë¡œ ë¡¤ë°± ì¤‘...'
            rm -rf apps/api-server
            mv apps/api-server.backup apps/api-server
            
            # PM2 ì¬ì‹œì‘
            pm2 restart ${{ env.PM2_APP_NAME }}
            echo 'ë¡¤ë°± ì™„ë£Œ'
          else
            echo 'ë°±ì—… íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. ìˆ˜ë™ ë³µêµ¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.'
          fi
        "
        
    - name: Rollback notification
      run: |
        echo "ğŸ”„ API ì„œë²„ ë¡¤ë°± ì™„ë£Œ"
        echo "âš ï¸  ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤."